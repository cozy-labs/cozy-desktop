/* @flow */
/* eslint-env mocha */

const _ = require('lodash')
const sinon = require('sinon')
const should = require('should')
const path = require('path')

const { Merge } = require('../../core/merge')
const metadata = require('../../core/metadata')
const { otherSide } = require('../../core/side')

const configHelpers = require('../support/helpers/config')
const cozyHelpers = require('../support/helpers/cozy')
const { onPlatform, onPlatforms } = require('../support/helpers/platform')
const pouchHelpers = require('../support/helpers/pouch')
const Builders = require('../support/builders')

/* Resolves with an object describing the side-effects of a Merge call.
 *
 * The returned object has the following properties:
 *
 * - `savedDocs`: Which docs were changed in `Pouch`
 * - `resolvedConflicts`: Which conflits were resolved on which side
 */
async function mergeSideEffects(
  { merge, pouch } /*: * */,
  mergeCall /*: () => Promise<*> */
) {
  const { last_seq: lastSeq } = await pouch.db.changes({ since: 'now' })

  if (merge.resolveConflictAsync.restore) merge.resolveConflictAsync.restore()
  const { resolveConflictAsync } = merge
  sinon.stub(merge, 'resolveConflictAsync').callsFake((...args) => {
    const clones = args.map(arg => _.cloneDeep(arg))
    return resolveConflictAsync(...clones)
  })

  await mergeCall()

  const opts = { since: lastSeq, include_docs: true }
  const { results } = await pouch.db.changes(opts)
  const savedDocs = results.map(({ doc }) => {
    // Don't include _rev in assertions: they are randomly generated by Pouch,
    // which makes them hard to compare.
    delete doc._rev

    // Don't include fileids in assertions: they are specific to Windows and
    // not really useful at the Merge level.
    delete doc.fileid

    return doc
  })

  return {
    savedDocs,
    resolvedConflicts: merge.resolveConflictAsync.args.map(([side, doc]) => [
      side,
      // Include only properties that are relevant in conflict resolution:
      _.pick(doc, [
        // The path is necessary to:
        // - generate the new file/dir name including the conflict suffix.
        // - rename the conflicting file/dir on the local side.
        'path',
        // The remote._id is necessary to rename the conflicting file/dir on
        // the remote side. Actually the remote._rev is not used although
        // we're currently including it in the test-asserted data as part of
        // the remote property.
        'remote'
      ])
      // Don't include the existing version: it is only useful for
      // logging / debugging and has no impact on conflict resolution.
    ])
  }
}

function increasedSides(sides, sideName, count) {
  return {
    ...sides,
    target: sides.target + count,
    [sideName]: sides[sideName] + count
  }
}

describe('Merge', function() {
  let builders

  before('instanciate config', configHelpers.createConfig)
  beforeEach('instanciate pouch', pouchHelpers.createDatabase)
  beforeEach('instanciate merge', function() {
    this.side = 'local'
    this.merge = new Merge(this.pouch)
    this.merge.local = { moveAsync: sinon.stub().resolves() }
    this.merge.remote = { moveAsync: sinon.stub().resolves() }
    builders = new Builders({ cozy: cozyHelpers.cozy, pouch: this.pouch })
  })
  afterEach('clean pouch', pouchHelpers.cleanDatabase)
  afterEach('clean remote', cozyHelpers.deleteAll)
  after('clean config directory', configHelpers.cleanConfig)

  describe('addFile', function() {
    it('saves the new file', async function() {
      const doc = builders
        .metafile()
        .path('new-file')
        .data('content')
        .tags('courge', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    context('remote', function() {
      context('when a file with the same path exists', function() {
        let oldRemoteFile, file

        beforeEach('create a file', async function() {
          oldRemoteFile = await builders
            .remoteFile()
            .inRootDir()
            .name('BUZZ.JPG')
            .data('image')
            .tags('foo')
            .contentType('image/jpeg')
            .build()
          file = await builders
            .metafile()
            .fromRemote(oldRemoteFile)
            .upToDate()
            .create()
        })

        it('can update the metadata', async function() {
          const newRemoteFile = await builders
            .remoteFile(oldRemoteFile)
            .tags('bar', 'baz')
            .build()
          const doc = builders
            .metafile()
            .fromRemote(newRemoteFile)
            .unmerged('remote')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.addFileAsync('remote', _.cloneDeep(doc))
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaults(
                {
                  tags: ['bar', 'baz'],
                  sides: increasedSides(file.sides, 'remote', 1),
                  remote: newRemoteFile
                },
                _.omit(file, ['_rev', 'fileid'])
              )
            ],
            resolvedConflicts: []
          })
        })
      })
    })

    context('when the path was used in the past', function() {
      const path = 'file-created-deleted-and-then-recreated'

      beforeEach(async function() {
        const was = await builders
          .metafile()
          .path(path)
          .data('content')
          .create()
        await this.pouch.remove(was)
      })

      it('saves the new file with the correct side number', async function() {
        const doc = builders
          .metafile()
          .path(path)
          .data('file content')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { target: 1, [this.side]: 1 }
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a file with the same path exists', function() {
      let file

      beforeEach('create a file', async function() {
        file = await builders
          .metafile()
          .path('BUZZ.JPG')
          .data('image')
          .type('image/jpeg')
          .ino(123)
          .updatedAt(new Date())
          .upToDate()
          .create()
      })

      it('can update the metadata', async function() {
        const newDate = new Date().toISOString()
        const doc = builders
          .metafile(file)
          .updatedAt(newDate)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                local: doc.local
              },
              _.omit(file, ['_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('can update the file record', async function() {
        const newDate = new Date().toISOString()
        const doc = builders
          .metafile(file)
          .ino(456)
          .data('new image')
          .updatedAt(newDate)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                ino: doc.ino,
                md5sum: doc.md5sum,
                size: doc.size,
                updated_at: doc.updated_at,
                sides: increasedSides(file.sides, 'local', 1),
                overwrite: file,
                local: doc.local
              },
              _.omit(file, ['_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('resolves an identity conflict with an existing file', async function() {
        await builders
          .metafile()
          .path('bar')
          .upToDate()
          .create()
        const doc = builders
          .metafile()
          .path('BAR')
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('remote', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [['remote', _.pick(doc, ['path', 'remote'])]]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not have identity conflicts', async function() {
        await builders
          .metafile()
          .path('bar')
          .upToDate()
          .create()
        const doc = builders
          .metafile()
          .path('BAR')
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('remote', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { target: 1, remote: 1 }
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('resolves a conflict with an existing dir', async function() {
      const existingLocalDir = await builders
        .metadir()
        .sides({ local: 1 })
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(existingLocalDir.path)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(newRemoteFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteFile, ['path', 'remote'])]
        ]
      })
    })

    it('does nothing for an already merged file (aka idempotence)', async function() {
      const mergedFile = await builders
        .metafile()
        .sides({ remote: 1 })
        .create()
      const sameFile = builders
        .metafile(mergedFile)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('updates the local metadata only when it has changed', async function() {
      const mergedFile = await builders
        .metafile()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .create()
      const sameFile = builders
        .metafile(mergedFile)
        .updatedAt(new Date())
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('local', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFile.local
            },
            _.omit(mergedFile, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('sets the local metadata when it is missing', async function() {
      const mergedFile = await builders
        .metafile()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .noLocal()
        .create()
      const sameFile = builders
        .metafile(mergedFile)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('local', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFile.local
            },
            _.omit(mergedFile, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps an existing local metadata when it is not present in the new doc', async function() {
      const oldRemoteFile = await builders
        .remoteFile()
        .updatedAt(2020, 5, 19, 11, 9, 0)
        .build()
      const mergedFile = await builders
        .metafile()
        .fromRemote(oldRemoteFile)
        .upToDate()
        .create()
      const newRemoteFile = await builders.remoteFile(oldRemoteFile).build()
      const sameFile = builders
        .metafile()
        .fromRemote(newRemoteFile)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              sides: increasedSides(mergedFile.sides, 'remote', 1),
              local: mergedFile.local
            },
            _.omit(sameFile, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatform('win32', () => {
      describe('for an existing file without fileid', () => {
        let existingFile
        beforeEach(async () => {
          existingFile = await builders
            .metafile()
            .upToDate()
            .ino(1)
            .noFileid()
            .create()
        })

        context('when new local file metadata has a fileid', () => {
          let sameFile
          beforeEach(() => {
            sameFile = builders
              .metafile(existingFile)
              .ino(1)
              .unmerged('local')
              .build()
          })

          it('migrates the existing file', async function() {
            await this.merge.addFileAsync('local', _.cloneDeep(sameFile))

            const savedFile = await this.pouch.bySyncedPath(existingFile.path)
            should(savedFile).have.properties({ fileid: sameFile.fileid })
          })

          for (const side of ['local', 'both']) {
            context(`when existing file has ${side} side`, () => {
              beforeEach(async () => {
                const sides =
                  side === 'both' ? { local: 2, remote: 2 } : { [side]: 1 }
                existingFile = await builders
                  .metafile(existingFile)
                  .sides(sides)
                  .create()
                sameFile = builders
                  .metafile(existingFile)
                  .ino(1)
                  .unmerged('local')
                  .build()
              })

              it(`migrates local side`, async function() {
                await this.merge.addFileAsync('local', _.cloneDeep(sameFile))

                const expectedSides =
                  side === 'both'
                    ? {
                        target: existingFile.sides.target + 1,
                        local: existingFile.sides.local + 1,
                        remote: existingFile.sides.remote
                      }
                    : {
                        target: existingFile.sides.target + 1,
                        local: existingFile.sides.local + 1
                      }
                const savedFile = await this.pouch.bySyncedPath(
                  existingFile.path
                )
                should(savedFile).have.properties({ sides: expectedSides })
              })
            })
          }
        })

        context('when new file does not have a fileid', () => {
          let sameFile
          beforeEach(() => {
            sameFile = builders
              .metafile(existingFile)
              .unmerged('local')
              .build()
          })

          it('does not migrate the existing file', async function() {
            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(sameFile))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: []
            })
          })
        })
      })

      describe('for an existing file with fileid', () => {
        let existingFile
        beforeEach(async () => {
          existingFile = await builders
            .metafile()
            .upToDate()
            .ino(1)
            .create()
        })

        it('does not migrate the existing file', async function() {
          const sameFile = builders
            .metafile(existingFile)
            .unmerged('local')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.addFileAsync('local', _.cloneDeep(sameFile))
          )

          should(sideEffects).deepEqual({
            savedDocs: [],
            resolvedConflicts: []
          })
        })
      })
    })

    it('resolves a conflict on remote file addition with unsynced local file addition', async function() {
      const unsyncedLocalFile = await builders
        .metafile()
        .sides({ local: 1 })
        .data('local content')
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(unsyncedLocalFile.path)
        .data('remote content')
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(newRemoteFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteFile, ['path', 'remote'])]
        ]
      })
    })

    context('on initial scan', function() {
      it('overrides an unsynced local addition with a local update', async function() {
        const initialFile = await builders
          .metafile()
          .sides({ local: 1 })
          .ino(123)
          .noRemote()
          .data('initial content')
          .create()
        const offlineUpdate = await builders
          .metafile(initialFile)
          .data('offline update')
          .newerThan(initialFile)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(offlineUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(initialFile.sides, 'local', 1),
                // omit because builder.noRemote sets remote to undefined
                overwrite: _.omit(initialFile, ['remote'])
              },
              _.omit(offlineUpdate, ['_rev', 'fileid', 'remote'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('overrides an unsynced local update with a new one', async function() {
        const initial = await builders
          .metafile()
          .path('yafile')
          .sides({ local: 1 })
          .ino(37)
          .data('initial content')
          .create()
        const synced = await builders
          .metafile(initial)
          .upToDate()
          .create()
        const firstUpdate = await builders
          .metafile(synced)
          .changedSide('local')
          .data('first update')
          .create()
        const secondUpdate = builders
          .metafile(firstUpdate)
          .data('second update')
          .newerThan(firstUpdate)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(secondUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                sides: increasedSides(firstUpdate.sides, 'local', 1),
                overwrite: firstUpdate,
                remote: synced.remote
              },
              _.omit(secondUpdate, ['_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not update a locally unchanged file with an unsynced remote update', async function() {
        const initial = await builders
          .metafile()
          .sides({ local: 1 })
          .data('previous content')
          .create()
        const synced = await builders
          .metafile(initial)
          .upToDate()
          .create()
        await builders
          .metafile(synced)
          .changedSide('remote')
          .data('remote update')
          .overwrite(synced)
          .create()
        const sameAsSynced = builders
          .metafile(synced)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(sameAsSynced))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })

      it('updates without overwrite a locally updated file with an unsynced remote update', async function() {
        const initial = await builders
          .metafile()
          .sides({ local: 1 })
          .data('initial content')
          .create()
        const synced = await builders
          .metafile(initial)
          .upToDate()
          .create()
        const remoteUpdate = await builders
          .metafile(synced)
          .changedSide('remote')
          .data('remote update')
          .overwrite(synced)
          .create()
        const localUpdate = builders
          .metafile(synced)
          .data('local update')
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(localUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                sides: increasedSides(remoteUpdate.sides, 'remote', 1),
                local: localUpdate.local
              },
              _.omit(remoteUpdate, ['overwrite', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('updateFile', () => {
    let file

    beforeEach('create synced file', async function() {
      file = await builders
        .metafile()
        .path('FIZZBUZZ.JPG')
        .ino(3456)
        .data('image')
        .type('image/jpeg')
        .tags('foo')
        .upToDate()
        .updatedAt(new Date(2020, 5, 17, 15, 33, 30, 0)) // Necessary for date change tests
        .create()
    })

    it('creates the file if it does not exist', async function() {
      const doc = builders
        .metafile()
        .path('NEW-FILE')
        .data('content')
        .tags('courge', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    it('updates the remote metadata when content is the same', async function() {
      const doc = builders
        .metafile(file)
        .tags('bar', 'baz')
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        // Tags are only coming from the Cozy so we should not expect any tags
        // update coming from the local side.
        this.merge.updateFileAsync('remote', _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              _id: file._id,
              sides: increasedSides(file.sides, 'remote', 1),
              local: file.local
            },
            _.omit(doc, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('updates the local metadata when content is the same', async function() {
      const doc = builders
        .metafile(file)
        .updatedAt(new Date())
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: doc.local
            },
            _.omit(file, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('sets the local metadata when it is missing', async function() {
      const mergedFile = await builders
        .metafile()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .noLocal()
        .create()
      const sameFile = builders
        .metafile(mergedFile)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFile.local
            },
            _.omit(mergedFile, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps an existing local metadata when it is not present in the new doc', async function() {
      const initial = await builders
        .metafile()
        .data('initial content')
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .create()
      const update = builders
        .metafile(initial)
        .data('updated content')
        .updatedAt(new Date())
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('remote', _.cloneDeep(update))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              sides: increasedSides(initial.sides, 'remote', 1),
              local: initial.local,
              overwrite: initial
            },
            _.omit(update, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('overwrites the content when it was changed', async function() {
      const doc = builders
        .metafile(file)
        .data('new content')
        .tags('qux', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              _id: file._id,
              sides: increasedSides(file.sides, this.side, 1),
              overwrite: file,
              [otherSide(this.side)]: file[otherSide(this.side)]
            },
            _.omit(doc, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('rejects an unresolvable conflict with an existing directory', async function() {
      // FIXME: Why don't we resolve the conflict like everywhere else?
      const existingLocalDir = await builders
        .metadir()
        .sides({ local: 1 })
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(existingLocalDir.path)
        .unmerged('remote')
        .build()

      await should(
        this.merge.updateFileAsync('local', _.cloneDeep(newRemoteFile))
      ).be.rejectedWith(/conflict/)
    })

    it('resolves a conflict between a new remote update and a previous local version', async function() {
      const initial = await builders
        .metafile()
        .sides({ local: 1 })
        .ino(456)
        .data('initial content')
        .create()
      const synced = await builders
        .metafile(initial)
        .upToDate()
        .create()
      const mergedLocalUpdate = await builders
        .metafile(synced)
        .changedSide('local')
        .data('local update')
        .create()
      const newRemoteUpdate = builders
        .metafile(synced)
        .data('remote update')
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('remote', _.cloneDeep(newRemoteUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: {
                target: mergedLocalUpdate.sides.target + 1,
                local: mergedLocalUpdate.sides.local + 1
              }
            },
            _.omit(mergedLocalUpdate, ['_rev', 'fileid', 'remote']) // We're dissociating the local doc from the remote doc
          )
        ],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteUpdate, ['path', 'remote'])]
        ]
      })
    })

    it('does not update a locally unchanged file with an unsynced remote update', async function() {
      const initial = await builders
        .metafile()
        .sides({ local: 1 })
        .data('initial content')
        .create()
      const synced = await builders
        .metafile(initial)
        .upToDate()
        .create()
      await builders
        .metafile(synced)
        .changedSide('remote')
        .data('remote update')
        .overwrite(synced)
        .create()
      const unchangedLocal = builders
        .metafile(synced)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(unchangedLocal))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('updates without overwrite a locally updated file with an unsynced remote update', async function() {
      const initial = await builders
        .metafile()
        .sides({ local: 1 })
        .data('initial content')
        .create()
      const synced = await builders
        .metafile(initial)
        .upToDate()
        .create()
      const remoteUpdate = await builders
        .metafile(synced)
        .changedSide('remote')
        .data('remote update')
        .overwrite(synced)
        .create()
      const newLocalUpdate = builders
        .metafile(synced)
        .data('local update')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(newLocalUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              sides: increasedSides(remoteUpdate.sides, 'remote', 1),
              local: newLocalUpdate.local
            },
            _.omit(remoteUpdate, ['overwrite', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('does nothing when existing file is up to date', async function() {
      const initial = await builders
        .metafile()
        .sides({ [this.side]: 1 })
        .data('initial content')
        .create()
      const initialSynced = await builders
        .metafile(initial)
        .upToDate()
        .create()
      const update = await builders
        .metafile(initialSynced)
        .changedSide('local')
        .data('updated content')
        .create()
      const updateSynced = await builders
        .metafile(update)
        .updatedAt(new Date(2020, 5, 12, 10, 15, 0))
        .upToDate()
        .create()
      const sameUpdate = builders
        .metafile(updateSynced)
        .updatedAt(new Date())
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(sameUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              [this.side]: sameUpdate[this.side]
            },
            _.omit(updateSynced, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('creates a conflict when the file is a CozyÂ Note export', async function() {
      const remoteNote = await builders
        .remoteNote()
        .name('my-note.cozy-note')
        .data('initial content')
        .create()
      const synced = await builders
        .metafile()
        .fromRemote(remoteNote)
        .upToDate()
        .create()
      const localUpdate = builders
        .metafile(synced)
        .data('local update')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(localUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, local: 1 },
              metadata: {}
            },
            _.omit(localUpdate, ['_rev', 'remote'])
          )
        ],
        resolvedConflicts: [['remote', { path: synced.path }]]
      })
    })
  })

  describe('putFolder', () => {
    it('saves the new folder', async function() {
      const doc = builders
        .metadir()
        .path('NEW-FOLDER')
        .tags('courge', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    it('saves a new version of an existing folder', async function() {
      const old = await builders
        .metadir()
        .path('existing-folder')
        .sides({ [this.side]: 1 })
        .create()
      const doc = builders
        .metadir(old)
        .whateverChange()
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(old.sides, this.side, 1),
              [otherSide(this.side)]: old[otherSide(this.side)]
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the path was used in the past', function() {
      const path = 'folder-created-deleted-and-then-recreated'

      beforeEach(async function() {
        const was = await builders
          .metadir()
          .path(path)
          .sides({ [this.side]: 1 })
          .create()
        await this.pouch.remove(was)
      })

      it('saves the new folder with the correct side number', async function() {
        const doc = builders
          .metadir()
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { target: 1, [this.side]: 1 }
              },
              _.omit(doc, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('does nothing when existing folder is up to date', async function() {
      const old = await builders
        .metadir()
        .path('up-to-date-folder')
        .upToDate()
        .create()
      const doc = builders
        .metadir(old)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('resolves a conflict with an existing file', async function() {
      const existingLocalFile = await builders
        .metafile()
        .sides({ local: 1 })
        .create()
      const newRemoteDir = builders
        .metadir()
        .path(existingLocalFile.path)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('remote', _.cloneDeep(newRemoteDir))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteDir, ['path', 'remote'])]
        ]
      })
    })

    it('updates the local metadata only when it has changed', async function() {
      const mergedFolder = await builders
        .metadir()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .create()
      const sameFolder = builders
        .metadir(mergedFolder)
        .updatedAt(new Date())
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('local', _.cloneDeep(sameFolder))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFolder.local
            },
            _.omit(mergedFolder, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('sets the local metadata when it is missing', async function() {
      const mergedFolder = await builders
        .metadir()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .noLocal()
        .create()
      const sameFolder = builders
        .metadir(mergedFolder)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('local', _.cloneDeep(sameFolder))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFolder.local
            },
            _.omit(mergedFolder, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps an existing local metadata when it is not present in the new doc', async function() {
      const oldRemoteDir = await builders
        .remoteDir()
        .updatedAt(2020, 5, 19, 11, 9, 0)
        .build()
      const mergedFolder = await builders
        .metadir()
        .fromRemote(oldRemoteDir)
        .upToDate()
        .create()
      const newRemoteDir = await builders.remoteDir(oldRemoteDir).build()
      const sameFolder = builders
        .metadir()
        .fromRemote(newRemoteDir)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('remote', _.cloneDeep(sameFolder))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              sides: increasedSides(mergedFolder.sides, 'remote', 1),
              local: mergedFolder.local
            },
            _.omit(sameFolder, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context(
      'when doc can have an identity conflict with an existing dir',
      () => {
        let Alfred

        beforeEach(async function() {
          await builders
            .metadir()
            .path('alfred')
            .sides({ [otherSide(this.side)]: 1 })
            .create()
          Alfred = await builders
            .metadir()
            .path('Alfred')
            .unmerged(this.side)
            .build()
        })

        onPlatforms(['win32', 'darwin'], () => {
          it('resolves the conflict', async function() {
            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.putFolderAsync(this.side, _.cloneDeep(Alfred))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: [
                [this.side, _.pick(Alfred, ['path', 'remote'])]
              ]
            })
          })
        })

        onPlatform('linux', () => {
          it('saves the doc as a new doc', async function() {
            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.putFolderAsync(this.side, _.cloneDeep(Alfred))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaultsDeep(
                  {
                    sides: { target: 1, [this.side]: 1 }
                  },
                  Alfred
                )
              ],
              resolvedConflicts: []
            })
          })
        })
      }
    )
  })

  describe('moveFileAsync', function() {
    beforeEach('create parent folder', async function() {
      await builders
        .metadir()
        .path('FOO')
        .upToDate()
        .create()
    })

    context('local', () => {
      it('saves the new file and deletes the old one with move hints for writers', async function() {
        const was = await builders
          .metafile()
          .path('FOO/OLD')
          .ino(1)
          .upToDate()
          .data('content')
          .tags('courge', 'quux')
          .create()
        const doc = builders
          .metafile(was)
          .path('FOO/NEW')
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev', 'fileid']),
            _.defaultsDeep(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)],
                ino: was.ino
              },
              _.omit(doc, ['_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('remote', () => {
      it('saves the new file and deletes the old one with move hints for writers', async function() {
        const oldRemoteFile = await builders
          .remoteFile()
          .inRootDir()
          .name('OLD')
          .data('content')
          .shortRev(1)
          .build()
        const was = await builders
          .metafile()
          .fromRemote(oldRemoteFile)
          .ino(1)
          .upToDate()
          .create()
        const newRemoteFile = await builders
          .remoteFile(oldRemoteFile)
          .name('NEW')
          .shortRev(2)
          .build()
        const doc = builders
          .metafile()
          .fromRemote(newRemoteFile)
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev', 'fileid']),
            _.defaultsDeep(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [this.side]: was[this.side],
                ino: was.ino
              },
              _.omit(doc, ['_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('adds missing fields', async function() {
      const was = await builders
        .metafile()
        .path('FOO/OLD-MISSING-FIELDS.JPG')
        .ino(3854)
        .data('image')
        .type('image/jpeg')
        .tags('courge', 'quux')
        .upToDate()
        .create()
      const doc = builders
        .metafile(was)
        .path('FOO/NEW-MISSING-FIELDS.JPG')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc.path,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_rev', 'fileid']),
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: movedSrc,
              [otherSide(this.side)]: was[otherSide(this.side)]
            },
            _.omit(doc, ['fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the destination exists', () => {
      let existing

      beforeEach(async function() {
        existing = await builders
          .metafile()
          .path('DST_FILE')
          .updatedAt(new Date(2020, 5, 19, 12, 12, 0))
          .upToDate()
          .create()
      })

      it('overrides the existing destination document', async function() {
        const was = await builders
          .metafile()
          .path('SRC_FILE')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path(existing.path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaultsDeep(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']),
            _.defaults(
              {
                _id: doc._id,
                path: doc.path,
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                overwrite: existing,
                [this.side]: doc[this.side]
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      context('and we have unapplied modifications on the other side', () => {
        beforeEach(async function() {
          existing = await builders
            .metafile(existing)
            .data('new content')
            .changedSide('remote')
            .create()
        })

        it('resolves a conflict', async function() {
          const was = await builders
            .metafile()
            .path('SRC_FILE')
            .upToDate()
            .create()
          const doc = builders
            .metafile(was)
            .path(existing.path)
            .unmerged('local')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFileAsync(
              'local',
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const { _id: dstId, path: dstPath } = _.find(
            sideEffects.savedDocs,
            ({ path }) => path.match(/conflict/)
          )

          const movedSrc = _.defaults(
            {
              moveTo: dstPath,
              _deleted: true
            },
            was
          )
          should(sideEffects).deepEqual({
            savedDocs: [
              _.omit(movedSrc, ['_rev']),
              _.defaults(
                {
                  _id: dstId,
                  path: dstPath,
                  sides: increasedSides(was.sides, 'local', 1),
                  moveFrom: movedSrc,
                  remote: was.remote
                },
                doc
              )
            ],
            resolvedConflicts: [
              ['local', { path: doc.path, remote: was.remote }]
            ]
          })
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_FILE'

      beforeEach(async function() {
        const previous = await builders
          .metafile()
          .path(path)
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new file with the correct side', async function() {
        const was = await builders
          .metafile()
          .path('SRC_FILE')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('replaces a local move with an addition for a local-only file', async function() {
      const was = await builders
        .metafile()
        .path('FOO/OLD')
        .data('content')
        .tags('courge', 'quux')
        .sides({ local: 1 })
        .create()
      const doc = builders
        .metafile(was)
        .path('FOO/NEW')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('local', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const unsyncedFile = _.defaults(
        {
          sides: {},
          _deleted: true
        },
        _.omit(was, ['_rev', 'local', 'remote'])
      )
      const fileAddition = _.defaults(
        {
          sides: { target: 1, local: 1 }
        },
        doc
      )
      should(sideEffects).deepEqual({
        savedDocs: [unsyncedFile, fileAddition],
        resolvedConflicts: []
      })
    })

    it('replaces a remote move with an addition for a remote-only file', async function() {
      const oldRemoteFile = builders
        .remoteFile()
        .inRootDir()
        .name('OLD')
        .data('content')
        .build()
      const was = await builders
        .metafile()
        .fromRemote(oldRemoteFile)
        .sides({ remote: 1 })
        .create()
      const newRemoteFile = builders
        .remoteFile(oldRemoteFile)
        .name('NEW')
        .build()
      const doc = builders
        .metafile()
        .fromRemote(newRemoteFile)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('remote', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const unsyncedFile = _.defaults(
        {
          sides: {},
          _deleted: true
        },
        _.omit(was, ['_rev', 'local', 'remote'])
      )
      const fileAddition = _.defaults(
        {
          sides: { target: 1, remote: 1 }
        },
        doc
      )
      should(sideEffects).deepEqual({
        savedDocs: [unsyncedFile, fileAddition],
        resolvedConflicts: []
      })
    })

    it('does not identify the child move of a file following another unsynced move as an addition', async function() {
      const src = await builders
        .metadir()
        .path('SRC')
        .upToDate()
        .create()
      const file = await builders
        .metafile()
        .path('SRC/FILE')
        .upToDate()
        .create()
      const file2 = builders
        .metafile(file)
        .path('SRC/FILE2')
        .unmerged('local')
        .build()
      await this.merge.moveFileAsync(
        'local',
        _.cloneDeep(file2),
        _.cloneDeep(file)
      )
      const was = await this.pouch.bySyncedPath(file2.path)
      const dst = builders
        .metadir(src)
        .path('DST')
        .unmerged('local')
        .build()
      const doc = await builders
        .metafile(was)
        .path('DST/FILE2')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync('local', _.cloneDeep(dst), _.cloneDeep(src))
      )

      const movedSrc = _.defaults(
        {
          moveTo: dst.path,
          _deleted: true
        },
        src
      )
      const movedFile = _.defaults(
        {
          moveTo: doc.path,
          childMove: true,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_rev']),
          _.defaults(
            {
              sides: increasedSides(src.sides, this.side, 1),
              moveFrom: movedSrc,
              remote: src.remote
            },
            _.omit(dst, ['_rev'])
          ),
          _.omit(movedFile, ['_rev']),
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: movedFile,
              remote: was.remote
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('does not identify the local move of a file following an unsynced child move as an addition', async function() {
      const src = await builders
        .metadir()
        .path('SRC')
        .upToDate()
        .create()
      await builders
        .metafile()
        .path('SRC/FILE')
        .upToDate()
        .create()
      const dst = builders
        .metadir(src)
        .path('DST')
        .unmerged('local')
        .build()
      await this.merge.moveFolderAsync(
        'local',
        _.cloneDeep(dst),
        _.cloneDeep(src)
      )
      const was = await this.pouch.bySyncedPath(path.normalize('DST/FILE'))
      const doc = await builders
        .metafile(was)
        .path('DST/FILE2')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('local', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc.path,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_rev']),
          _.defaults(
            {
              sides: increasedSides(was.sides, 'local', 1),
              moveFrom: movedSrc,
              remote: was.remote
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const banana = await builders
          .metafile()
          .path('banana')
          .upToDate()
          .create()
        const BANANA = builders
          .metafile(banana)
          .path('BANANA')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(BANANA),
            _.cloneDeep(banana)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                sides: increasedSides(banana.sides, this.side, 1),
                path: BANANA.path,
                moveFrom: _.defaults(
                  {
                    moveTo: BANANA.path,
                    _deleted: true
                  },
                  banana
                ),
                [this.side]: BANANA[this.side]
              },
              _.omit(banana, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('resolves an identity conflict with an existing file', async function() {
        await builders
          .metafile()
          .path('QUX')
          .create()
        const was = await builders
          .metafile()
          .path('baz')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path('qux')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            [this.side, { path: doc.path, remote: was.remote }]
          ]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const banana = await builders
          .metafile()
          .path('banana')
          .upToDate()
          .create()
        const BANANA = builders
          .metafile(banana)
          .path('BANANA')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(BANANA),
            _.cloneDeep(banana)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: BANANA.path,
            _deleted: true
          },
          banana
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']),
            _.defaults(
              {
                sides: increasedSides(banana.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: banana[otherSide(this.side)]
              },
              BANANA
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not have identity conflicts', async function() {
        const was = await builders
          .metafile()
          .path('baz')
          .upToDate()
          .create()
        await builders
          .metafile()
          .path('QUX')
          .create()
        const doc = builders
          .metafile(was)
          .path('qux')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              _.omit(doc, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('moveFolderAsync', function() {
    beforeEach('create parent directory', async function() {
      await builders
        .metadir()
        .path('FOOBAR')
        .upToDate()
        .create()
    })

    context('local', () => {
      it('saves the new folder and deletes the old one with hints for writers', async function() {
        const was = await builders
          .metadir()
          .path('FOOBAR/OLD')
          .ino(666)
          .tags('courge', 'quux')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path('FOOBAR/NEW')
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            'local',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev', 'fileid']),
            _.defaults(
              {
                sides: increasedSides(was.sides, 'local', 1),
                moveFrom: movedSrc,
                remote: was.remote
              },
              _.omit(doc, ['_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('remote', () => {
      it('saves the new folder and deletes the old one with hints for writers', async function() {
        const oldRemoteDir = builders
          .remoteDir()
          .inRootDir()
          .name('OLD')
          .build()
        const was = await builders
          .metadir()
          .fromRemote(oldRemoteDir)
          .ino(666)
          .upToDate()
          .create()
        const newRemoteDir = builders
          .remoteDir(oldRemoteDir)
          .inRootDir()
          .name('NEW')
          .build()
        const doc = builders
          .metadir()
          .fromRemote(newRemoteDir)
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            'remote',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev', 'fileid']),
            _.defaults(
              {
                sides: increasedSides(was.sides, 'remote', 1),
                moveFrom: movedSrc,
                local: was.local,
                ino: was.ino
              },
              _.omit(doc, ['_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('replaces a local move with an addition for a local-only folder', async function() {
      const was = await builders
        .metadir()
        .path('FOOBAR/OLD')
        .ino(666)
        .tags('courge', 'quux')
        .sides({ local: 1 })
        .create()
      const doc = builders
        .metadir(was)
        .path('FOOBAR/NEW')
        .tags('courge', 'quux')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync('local', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const unsyncedFolder = _.defaults(
        {
          sides: {},
          _deleted: true
        },
        _.omit(was, ['_rev', 'fileid', 'local', 'remote'])
      )
      const folderAddition = _.defaults(
        {
          sides: { target: 1, local: 1 }
        },
        _.omit(doc, ['_rev', 'fileid'])
      )
      should(sideEffects).deepEqual({
        savedDocs: [unsyncedFolder, folderAddition],
        resolvedConflicts: []
      })
    })

    it('replaces a remote move with an addition for a remote-only folder', async function() {
      const oldRemoteDir = builders
        .remoteDir()
        .inRootDir()
        .name('OLD')
        .build()
      const was = await builders
        .metadir()
        .fromRemote(oldRemoteDir)
        .sides({ remote: 1 })
        .create()
      const newRemoteDir = builders
        .remoteDir(oldRemoteDir)
        .name('NEW')
        .build()
      const doc = builders
        .metadir()
        .fromRemote(newRemoteDir)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync('remote', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const unsyncedFolder = _.defaults(
        {
          sides: {},
          _deleted: true
        },
        _.omit(was, ['_rev', 'fileid', 'local', 'remote'])
      )
      const folderAddition = _.defaults(
        {
          sides: { target: 1, remote: 1 }
        },
        _.omit(doc, ['_rev'])
      )
      should(sideEffects).deepEqual({
        savedDocs: [unsyncedFolder, folderAddition],
        resolvedConflicts: []
      })
    })

    context('when the destination exists', () => {
      let existing

      context('and it is up-to-date', () => {
        beforeEach(async function() {
          existing = await builders
            .metadir()
            .path('DST_DIR')
            .upToDate()
            .create()
        })

        it('overwrites the destination', async function() {
          const was = await builders
            .metadir()
            .path('SRC_DIR')
            .upToDate()
            .create()
          const doc = builders
            .metadir(was)
            .path(existing.path)
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              this.side,
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const movedSrc = _.defaults(
            {
              moveTo: existing.path,
              _deleted: true
            },
            was
          )
          should(sideEffects).deepEqual({
            savedDocs: [
              _.omit(movedSrc, ['_rev']),
              _.defaults(
                {
                  _id: existing._id,
                  path: existing.path,
                  sides: increasedSides(was.sides, this.side, 1),
                  moveFrom: movedSrc,
                  overwrite: existing,
                  [otherSide(this.side)]: was[otherSide(this.side)]
                },
                doc
              )
            ],
            resolvedConflicts: []
          })
        })
      })

      context('and it is not at least up-to-date on the movement side', () => {
        beforeEach(async function() {
          existing = await builders
            .metadir()
            .path('DST_DIR')
            .changedSide(otherSide(this.side))
            .create()
        })

        it('resolves a conflict', async function() {
          const was = await builders
            .metadir()
            .path('SRC_DIR')
            .upToDate()
            .create()
          const doc = builders
            .metadir(was)
            .path(existing.path)
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              this.side,
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const { _id: dstId, path: dstPath } = _.find(
            sideEffects.savedDocs,
            ({ path }) => path.match(/conflict/)
          )

          const movedSrc = _.defaults(
            {
              moveTo: dstPath,
              _deleted: true
            },
            was
          )
          should(sideEffects).deepEqual({
            savedDocs: [
              _.omit(movedSrc, ['_rev']),
              _.defaults(
                {
                  _id: dstId,
                  path: dstPath,
                  sides: increasedSides(was.sides, this.side, 1),
                  moveFrom: movedSrc,
                  [otherSide(this.side)]: was[otherSide(this.side)]
                },
                doc
              )
            ],
            resolvedConflicts: [[this.side, _.pick(doc, ['path', 'remote'])]]
          })
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_DIR'

      beforeEach(async function() {
        const previous = await builders
          .metadir()
          .path(path)
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new directory with the correct side', async function() {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('does not create conflict for local-only existing folder.', async function() {
      const existing = await builders
        .metadir()
        .path('DST_DIR')
        .sides({ [this.side]: 1 })
        .create()
      const was = await builders
        .metadir()
        .path('SRC_DIR')
        .upToDate()
        .create()
      const doc = builders
        .metadir(was)
        .path(existing.path)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(
          this.side,
          _.cloneDeep(doc),
          _.cloneDeep(was)
        )
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc.path,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_rev']),
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: movedSrc,
              overwrite: existing,
              [otherSide(this.side)]: was[otherSide(this.side)]
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const apple = await builders
          .metadir()
          .path('apple')
          .upToDate()
          .create()
        const APPLE = builders
          .metadir(apple)
          .path('APPLE')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(APPLE),
            _.cloneDeep(apple)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                sides: increasedSides(apple.sides, this.side, 1),
                path: APPLE.path,
                moveFrom: _.defaults(
                  {
                    moveTo: APPLE.path,
                    _deleted: true
                  },
                  apple
                ),
                [this.side]: APPLE[this.side]
              },
              _.omit(apple, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('resolves an identity conflict when moving a synced folder to an existing path', async function() {
        await builders
          .metadir()
          .path('LINUX')
          .create()
        const torvalds = await builders
          .metadir()
          .path('torvalds')
          .upToDate()
          .create()
        const linux = builders
          .metadir(torvalds)
          .path('linux')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(linux),
            _.cloneDeep(torvalds)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [], // XXX: The conflict will be considered as a new change and merged later
          resolvedConflicts: [[this.side, _.pick(linux, ['path', 'remote'])]]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const apple = await builders
          .metadir()
          .path('apple')
          .upToDate()
          .create()
        const APPLE = builders
          .metadir(apple)
          .path('APPLE')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(APPLE),
            _.cloneDeep(apple)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: APPLE.path,
            _deleted: true
          },
          apple
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']),
            _.defaults(
              {
                sides: increasedSides(apple.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: apple[otherSide(this.side)]
              },
              APPLE
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not have identity conflicts', async function() {
        await builders
          .metadir()
          .path('NUKEM')
          .create()
        const duke = await builders
          .metadir()
          .path('duke')
          .upToDate()
          .create()
        const nukem = builders
          .metadir(duke)
          .path('nukem')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(nukem),
            _.cloneDeep(duke)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: nukem.path,
            _deleted: true
          },
          duke
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']),
            _.defaults(
              {
                sides: increasedSides(duke.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: duke[otherSide(this.side)]
              },
              nukem
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('handles overwritten descendants', async function() {
      const srcDir = await builders
        .metadir()
        .path('src')
        .upToDate()
        .create()
      const srcFile = await builders
        .metafile()
        .path('src/file')
        .upToDate()
        .create()
      const oldDst = await builders
        .metadir()
        .path('dst')
        .upToDate()
        .create()
      const dstFile = await builders
        .metafile()
        .path('dst/file')
        .upToDate()
        .create()
      const dstDir = builders
        .metadir(srcDir)
        .path('dst')
        .overwrite(oldDst)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(
          this.side,
          _.cloneDeep(dstDir),
          _.cloneDeep(srcDir)
        )
      )

      const movedSrcDir = _.defaults(
        {
          moveTo: dstDir.path,
          _deleted: true
        },
        srcDir
      )
      const movedSrcFile = _.defaults(
        {
          moveTo: dstFile.path,
          childMove: true,
          _deleted: true
        },
        srcFile
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrcDir, ['_rev']),
          _.defaults(
            {
              sides: increasedSides(srcDir.sides, this.side, 1),
              moveFrom: movedSrcDir,
              overwrite: oldDst,
              [otherSide(this.side)]: srcDir[otherSide(this.side)]
            },
            _.omit(dstDir, ['_rev'])
          ),
          _.omit(movedSrcFile, ['_rev']),
          _.defaultsDeep(
            {
              _id: dstFile._id,
              path: dstFile.path,
              sides: increasedSides(srcFile.sides, this.side, 1),
              moveFrom: movedSrcFile,
              [this.side]: { path: dstFile[this.side].path }
            },
            _.omit(srcFile, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('moveFolderRecursively', function() {
    it('moves the folder and files/folders inside it', async function() {
      const was = await builders
        .metadir()
        .path('my-folder')
        .upToDate()
        .create()
      const subdir = await builders
        .metadir()
        .path('my-folder/folder-9')
        .upToDate()
        .create()
      const subfile = await builders
        .metafile()
        .path('my-folder/file-9')
        .upToDate()
        .create()
      const doc = builders
        .metadir(was)
        .path('DESTINATION')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderRecursivelyAsync(
          this.side,
          _.cloneDeep(doc),
          _.cloneDeep(was)
        )
      )

      const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

      const movedDir = _.defaults(
        {
          moveTo: doc.path,
          _deleted: true
        },
        was
      )
      const movedSubfile = _.defaults(
        {
          moveTo: movedPath(subfile),
          childMove: true,
          _deleted: true
        },
        subfile
      )
      const movedSubdir = _.defaults(
        {
          moveTo: movedPath(subdir),
          childMove: true,
          _deleted: true
        },
        subdir
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedDir, ['_rev']),
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: movedDir,
              [otherSide(this.side)]: was[otherSide(this.side)]
            },
            _.omit(doc, ['_rev'])
          ),
          _.omit(movedSubfile, ['_rev']),
          _.defaultsDeep(
            {
              _id: metadata.id(movedPath(subfile)),
              path: movedPath(subfile),
              sides: increasedSides(subfile.sides, this.side, 1),
              moveFrom: movedSubfile,
              [this.side]: { path: movedPath(subfile) },
              [otherSide(this.side)]: movedSubfile[otherSide(this.side)]
            },
            _.omit(subfile, ['_rev'])
          ),
          _.omit(movedSubdir, ['_rev']),
          _.defaultsDeep(
            {
              _id: metadata.id(movedPath(subdir)),
              path: movedPath(subdir),
              sides: increasedSides(subdir.sides, this.side, 1),
              moveFrom: movedSubdir,
              [this.side]: { path: movedPath(subdir) },
              [otherSide(this.side)]: movedSubdir[otherSide(this.side)]
            },
            _.omit(subdir, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context('local', () => {
      it('adds an unsynced remote file to the destination folder', async function() {
        const was = await builders
          .metadir()
          .path('ADDED_DIR')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path('MOVED_DIR')
          .unmerged('local')
          .build()
        const unsyncedRemoteFile = await builders
          .remoteFile()
          .inDir(was.remote)
          .name('unsynced-file')
          .build()
        const unsyncedFile = await builders
          .metafile()
          .fromRemote(unsyncedRemoteFile)
          .noLocal()
          .sides({ remote: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            'local',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: increasedSides(was.sides, 'local', 1),
                moveFrom: movedSrc,
                remote: was.remote
              },
              _.omit(doc, ['_rev'])
            ),
            _.defaults(
              {
                sides: {},
                _deleted: true
              },
              _.omit(unsyncedFile, ['_rev', 'remote']) // TODO: Compare _revs
            ),
            _.defaults(
              {
                _id: metadata.id(movedPath(unsyncedFile)),
                path: movedPath(unsyncedFile),
                sides: { target: 1, remote: 1 }
              },
              _.omit(unsyncedFile, ['_rev']) // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('remote', () => {
      it('adds an unsynced local file to the destination folder', async function() {
        const oldRemoteDir = builders
          .remoteDir()
          .inRootDir()
          .name('ADDED_DIR')
          .build()
        const was = await builders
          .metadir()
          .fromRemote(oldRemoteDir)
          .upToDate()
          .create()
        const newRemoteDir = builders
          .remoteDir(oldRemoteDir)
          .name('MOVED_DIR')
          .build()
        const doc = builders
          .metadir()
          .fromRemote(newRemoteDir)
          .unmerged('remote')
          .build()
        const unsyncedFile = await builders
          .metafile()
          .path('ADDED_DIR/unsynced-file')
          .noRemote()
          .sides({ local: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            'remote',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']), // TODO: Compare _revs
            _.defaults(
              {
                sides: increasedSides(was.sides, 'remote', 1),
                moveFrom: movedSrc,
                local: was.local
              },
              doc
            ),
            _.defaults(
              {
                sides: {},
                _deleted: true
              },
              _.omit(unsyncedFile, ['_rev', 'local']) // TODO: Compare _revs
            ),
            _.defaults(
              {
                _id: metadata.id(movedPath(unsyncedFile)),
                path: movedPath(unsyncedFile),
                sides: { target: 1, local: 1 }
              },
              _.omit(unsyncedFile, ['_rev']) // TODO: Compare _revs
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_DIR'

      beforeEach(async function() {
        const previous = await builders
          .metadir()
          .path(path)
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new directory with the correct side', async function() {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              _.omit(doc, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when the destination of a child has existed', () => {
      const parentPath = 'DST_DIR'
      const childName = 'CHILD'

      beforeEach(async function() {
        const previous = await builders
          .metadata()
          .path(`${parentPath}/${childName}`)
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new child with the correct side', async function() {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const child = await builders
          .metadata()
          .path(`SRC_DIR/${childName}`)
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(parentPath)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        const movedDir = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        const movedChild = _.defaults(
          {
            moveTo: movedPath(child),
            childMove: true,
            _deleted: true
          },
          child
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedDir, ['_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedDir,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              doc
            ),
            _.omit(movedChild, ['_rev']),
            _.defaultsDeep(
              {
                _id: metadata.id(movedPath(child)),
                path: movedPath(child),
                sides: increasedSides(child.sides, this.side, 1),
                moveFrom: movedChild,
                [this.side]: { path: movedPath(child) }
              },
              _.omit(child, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    onPlatform('darwin', () => {
      context(
        'when the parent normalization differs in its children paths',
        () => {
          it('correctly replaces the NFD parent part in the children paths', async function() {
            const nfdParentPath = 'ÃnoncÃ©s'.normalize('NFD')
            const nfcParentPath = nfdParentPath.normalize('NFC')
            const was = await builders
              .metadir()
              .path(nfcParentPath)
              .upToDate()
              .create()
            const subdir = await builders
              .metadir()
              .path(path.join(nfdParentPath, 'folder-9'))
              .upToDate()
              .create()
            const subfile = await builders
              .metafile()
              .path(path.join(subdir.path, 'file-9'))
              .upToDate()
              .create()
            const doc = builders
              .metadir(was)
              .path('DESTINATION')
              .unmerged(this.side)
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.moveFolderRecursivelyAsync(
                this.side,
                _.cloneDeep(doc),
                _.cloneDeep(was)
              )
            )

            const movedDir = _.defaults(
              {
                moveTo: doc.path,
                _deleted: true
              },
              was
            )
            const movedSubdirPath = path.join(doc.path, 'folder-9')
            const movedSubdir = _.defaults(
              {
                moveTo: movedSubdirPath,
                childMove: true,
                _deleted: true
              },
              subdir
            )
            const movedSubfilePath = path.join(movedSubdirPath, 'file-9')
            const movedSubfile = _.defaultsDeep(
              {
                moveTo: movedSubfilePath,
                childMove: true,
                _deleted: true
              },
              subfile
            )
            should(sideEffects).deepEqual({
              savedDocs: [
                _.omit(movedDir, ['_rev']),
                _.defaults(
                  {
                    sides: increasedSides(was.sides, this.side, 1),
                    moveFrom: movedDir,
                    [otherSide(this.side)]: was[otherSide(this.side)]
                  },
                  _.omit(doc, ['_rev'])
                ),
                _.omit(movedSubdir, ['_rev']),
                _.defaultsDeep(
                  {
                    _id: metadata.id(movedSubdirPath),
                    path: movedSubdirPath,
                    sides: increasedSides(subdir.sides, this.side, 1),
                    moveFrom: movedSubdir,
                    [this.side]: { path: movedSubdirPath }
                  },
                  _.omit(subdir, ['_rev'])
                ),
                _.omit(movedSubfile, ['_rev']),
                _.defaultsDeep(
                  {
                    _id: metadata.id(movedSubfilePath),
                    path: movedSubfilePath,
                    sides: increasedSides(subfile.sides, this.side, 1),
                    moveFrom: movedSubfile,
                    [this.side]: { path: movedSubfilePath }
                  },
                  _.omit(subfile, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })

          it('correctly replaces the NFC parent part in the children paths', async function() {
            const nfdParentPath = 'ÃnoncÃ©s'.normalize('NFD')
            const nfcParentPath = nfdParentPath.normalize('NFC')
            const was = await builders
              .metadir()
              .path(nfdParentPath)
              .upToDate()
              .create()
            const subdir = await builders
              .metadir()
              .path(path.join(nfcParentPath, 'folder-9'))
              .upToDate()
              .create()
            const subfile = await builders
              .metafile()
              .path(path.join(subdir.path, 'file-9'))
              .upToDate()
              .create()
            const doc = builders
              .metadir(was)
              .path('DESTINATION')
              .unmerged(this.side)
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.moveFolderRecursivelyAsync(
                this.side,
                _.cloneDeep(doc),
                _.cloneDeep(was)
              )
            )

            const movedDir = _.defaults(
              {
                moveTo: doc.path,
                _deleted: true
              },
              was
            )
            const movedSubdirPath = path.join(doc.path, 'folder-9')
            const movedSubdir = _.defaults(
              {
                moveTo: movedSubdirPath,
                childMove: true,
                _deleted: true
              },
              subdir
            )
            const movedSubfilePath = path.join(movedSubdirPath, 'file-9')
            const movedSubfile = _.defaults(
              {
                moveTo: movedSubfilePath,
                childMove: true,
                _deleted: true
              },
              subfile
            )
            should(sideEffects).deepEqual({
              savedDocs: [
                _.omit(movedDir, ['_rev']),
                _.defaults(
                  {
                    sides: increasedSides(was.sides, this.side, 1),
                    moveFrom: movedDir,
                    [otherSide(this.side)]: was[otherSide(this.side)]
                  },
                  _.omit(doc, ['_rev'])
                ),
                _.omit(movedSubdir, ['_rev']),
                _.defaultsDeep(
                  {
                    _id: metadata.id(movedSubdirPath),
                    path: movedSubdirPath,
                    sides: increasedSides(subdir.sides, this.side, 1),
                    moveFrom: movedSubdir,
                    [this.side]: { path: movedSubdirPath }
                  },
                  _.omit(subdir, ['_rev'])
                ),
                _.omit(movedSubfile, ['_rev']),
                _.defaultsDeep(
                  {
                    _id: metadata.id(movedSubfilePath),
                    path: movedSubfilePath,
                    sides: increasedSides(subfile.sides, this.side, 1),
                    moveFrom: movedSubfile,
                    [this.side]: { path: movedSubfilePath }
                  },
                  _.omit(subfile, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )
    })
  })

  describe('trashFolderAsync', () => {
    it('does not trash a folder if the other side has added a new file in it', async function() {
      const was = await builders
        .metadir()
        .path('trashed-folder')
        .upToDate()
        .trashed()
        .create()
      await builders
        .metafile()
        .path('trashed-folder/file')
        .sides({ [otherSide(this.side)]: 1 })
        .create()
      const doc = await builders
        .metadir(was)
        .path(`.cozy_trash/${was.path}`)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.trashFolderAsync(
          this.side,
          _.cloneDeep(was),
          _.cloneDeep(doc)
        )
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: {
                target: was.sides.target + 1,
                [otherSide(this.side)]: was.sides[otherSide(this.side)] + 1
              }
            },
            _.omit(was, ['trashed', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('deleteFile', () => {
    it('deletes a file', async function() {
      const doc = await builders
        .metafile()
        .path('FILE')
        .data('content')
        .sides({ [this.side]: 1 })
        .create()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(doc.sides, this.side, 1),
              deleted: true
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('removes move hints', async function() {
      const old = await builders
        .metafile()
        .path('FILE')
        .moveTo('MOVED')
        .data('content')
        .sides({ [this.side]: 1 })
        .create()
      const doc = await builders
        .metafile()
        .moveFrom(old)
        .path('MOVED')
        .sides({ [this.side]: 2 })
        .create()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(doc.sides, this.side, 1),
              deleted: true
            },
            _.omit(doc, ['moveFrom', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('deleteFolder', function() {
    it('deletes a folder', async function() {
      const doc = await builders
        .metadir()
        .path('FOLDER')
        .sides({ [this.side]: 1 })
        .create()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(doc.sides, this.side, 1),
              deleted: true
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('removes nested content', async function() {
      const doc = await builders
        .metadir()
        .path('FOLDER')
        .sides({ [this.side]: 1 })
        .create()
      const subdir = await builders
        .metafile()
        .path('FOLDER/DIR')
        .sides({ [this.side]: 1 })
        .create()
      const subsubdir = await builders
        .metafile()
        .path('FOLDER/DIR/DIR')
        .sides({ [this.side]: 1 })
        .create()
      const subsubsubfile = await builders
        .metafile()
        .path('FOLDER/DIR/DIR/FILE')
        .sides({ [this.side]: 1 })
        .data('content')
        .create()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(subsubsubfile.sides, this.side, 1),
              deleted: true
            },
            _.omit(subsubsubfile, ['_rev'])
          ),
          _.defaults(
            {
              sides: increasedSides(subsubdir.sides, this.side, 1),
              deleted: true
            },
            _.omit(subsubdir, ['_rev'])
          ),
          _.defaults(
            {
              sides: increasedSides(subdir.sides, this.side, 1),
              deleted: true
            },
            _.omit(subdir, ['_rev'])
          ),
          _.defaults(
            {
              sides: increasedSides(doc.sides, this.side, 1),
              deleted: true
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('removes move hints', async function() {
      // TODO: make sure we remove the move hints on children. This will be part
      // of a larger refactoring to make sure folders are trashed with their
      // hierarchy.
      const old = await builders
        .metadir()
        .path('FOLDER')
        .moveTo('MOVED')
        .sides({ [this.side]: 1 })
        .create()
      const doc = await builders
        .metadir()
        .moveFrom(old)
        .path('MOVED')
        .sides({ [this.side]: 1 })
        .create()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(doc.sides, this.side, 1),
              deleted: true
            },
            _.omit(doc, ['moveFrom', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('trashFileAsync', () => {
    context('when metadata are found in Pouch', () => {
      it('deletes it with trashed property and up-to-date sides info', async function() {
        const was = await builders
          .metafile()
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when metadata are not found in Pouch', () => {
      it('does nothing', async function() {
        const was = builders.metafile().build()
        const doc = builders
          .metafile(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when docType does not match', () => {
      it('does nothing', async function() {
        const was = await builders.metafile().create()
        const doc = builders
          .metadir()
          .path(was.path)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('trashFolderAsync', () => {
    context('when metadata are found in Pouch', () => {
      it('deletes it with trashed property and up-to-date sides info', async function() {
        const was = await builders
          .metadir()
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when metadata are not found in Pouch', () => {
      it('does nothing', async function() {
        const was = builders.metadir().build()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when docType does not match', () => {
      it('does nothing', async function() {
        const was = await builders.metadir().create()
        const doc = builders
          .metafile()
          .path(was.path)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('migrateFileid(existing, fileid)', () => {
    const fileid = '0x0000000000000001'
    let existing, updatedDoc

    context('when existing doc is not synced but missing a fileid', () => {
      beforeEach(async function() {
        existing = await builders
          .metadata()
          .ino(1)
          .noFileid()
          .sides({ local: 1 })
          .noRemote()
          .create()
      })

      it('does not raise Invariant errors', async function() {
        should(() => {
          this.merge.migrateFileid(_.cloneDeep(existing), fileid)
        }).not.throw()
      })

      it('updates doc with the fileid', async function() {
        await this.merge.migrateFileid(_.cloneDeep(existing), fileid)

        updatedDoc = await this.pouch.bySyncedPath(existing.path)

        should(updatedDoc).have.property('fileid', fileid)
      })
    })

    context(
      'when existing doc is already up-to-date but missing a fileid',
      () => {
        beforeEach(async function() {
          existing = await builders
            .metadata()
            .ino(1)
            .noFileid()
            .upToDate()
            .create()

          await this.merge.migrateFileid(_.cloneDeep(existing), fileid)

          updatedDoc = await this.pouch.bySyncedPath(existing.path)
        })

        it('updates doc with the fileid', async () => {
          should(updatedDoc).have.property('fileid', fileid)
        })

        it('does not make the doc out-of-date in order to prevent useless sync', async function() {
          should.not.exist(metadata.outOfDateSide(updatedDoc))
        })
      }
    )

    context('when existing doc is being synced and missing a fileid', () => {
      beforeEach(async function() {
        existing = await builders
          .metadata()
          .upToDate()
          .changedSide(this.side)
          .ino(1)
          .noFileid()
          .create()
        await this.merge.migrateFileid(_.cloneDeep(existing), fileid)

        updatedDoc = await this.pouch.bySyncedPath(existing.path)
      })

      it('updates doc with the fileid', async () => {
        should(updatedDoc).have.property('fileid', fileid)
      })

      it('keeps the same out-of-date side in order not to prevent sync', async function() {
        should(metadata.outOfDateSide(updatedDoc)).equal(otherSide(this.side))
      })
    })
  })
})
