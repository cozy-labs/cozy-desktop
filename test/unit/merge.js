/* @flow */
/* eslint-env mocha */

const _ = require('lodash')
const sinon = require('sinon')
const should = require('should')
const path = require('path')

const { Merge } = require('../../core/merge')
const metadata = require('../../core/metadata')
const { otherSide } = require('../../core/side')
const pathUtils = require('../../core/utils/path')

const configHelpers = require('../support/helpers/config')
const cozyHelpers = require('../support/helpers/cozy')
const { onPlatform, onPlatforms } = require('../support/helpers/platform')
const pouchHelpers = require('../support/helpers/pouch')
const Builders = require('../support/builders')

/* Resolves with an object describing the side-effects of a Merge call.
 *
 * The returned object has the following properties:
 *
 * - `savedDocs`: Which docs were changed in `Pouch`
 * - `resolvedConflicts`: Which conflits were resolved on which side
 */
async function mergeSideEffects(
  { merge, pouch } /*: * */,
  mergeCall /*: () => Promise<*> */
) {
  const { last_seq: lastSeq } = await pouch.db.changes({ since: 'now' })

  if (merge.resolveConflictAsync.restore) merge.resolveConflictAsync.restore()
  const { resolveConflictAsync } = merge
  sinon.stub(merge, 'resolveConflictAsync').callsFake((...args) => {
    const clones = args.map(arg => _.cloneDeep(arg))
    return resolveConflictAsync(...clones)
  })

  await mergeCall()

  const opts = { since: lastSeq, include_docs: true }
  const { results } = await pouch.db.changes(opts)
  const savedDocs = results.map(({ doc }) => {
    // Don't include _id and _rev in assertions: they are randomly generated by
    // Pouch, which makes them hard to compare.
    delete doc._id
    delete doc._rev

    // Don't include fileids in assertions: they are specific to Windows and
    // not really useful at the Merge level.
    delete doc.fileid

    return doc
  })

  return {
    savedDocs,
    resolvedConflicts: merge.resolveConflictAsync.args.map(([side, doc]) => [
      side,
      // Include only properties that are relevant in conflict resolution:
      _.pick(doc, [
        // The path is necessary to:
        // - generate the new file/dir name including the conflict suffix.
        // - rename the conflicting file/dir on the local side.
        'path',
        // The remote._id is necessary to rename the conflicting file/dir on
        // the remote side. Actually the remote._rev is not used although
        // we're currently including it in the test-asserted data as part of
        // the remote property.
        'remote'
      ])
      // Don't include the existing version: it is only useful for
      // logging / debugging and has no impact on conflict resolution.
    ])
  }
}

function increasedSides(sides, sideName, count) {
  const increasedSide = sides[sideName] + count
  return {
    ...sides,
    target: increasedSide,
    [sideName]: increasedSide
  }
}

describe('Merge', function() {
  let builders

  before('instanciate config', configHelpers.createConfig)
  beforeEach('instanciate pouch', pouchHelpers.createDatabase)
  beforeEach('instanciate merge', function() {
    this.side = 'local'
    this.merge = new Merge(this.pouch)
    this.merge.local = {
      moveAsync: sinon.stub().callsFake(doc => {
        // XXX: We cannot stub `fs.rename` as it's directly imported by `Local`
        // but we care about the `local` attribute being updated so we
        // explicitely call `metadata.updateLocal()`.
        metadata.updateLocal(doc)
      })
    }
    this.merge.remote = {
      moveAsync: sinon.stub().callsFake(doc => {
        // XXX: It would be cumbersome to stub the content of this method but we
        // care about the `remote` attribute being updated so we explicitely
        // call `metadata.updateRemote()`.
        metadata.updateRemote(doc, { path: pathUtils.localToRemote(doc.path) })
      })
    }
    builders = new Builders({ cozy: cozyHelpers.cozy, pouch: this.pouch })
  })
  afterEach('clean pouch', pouchHelpers.cleanDatabase)
  afterEach('clean remote', cozyHelpers.deleteAll)
  after('clean config directory', configHelpers.cleanConfig)

  describe('addFile', function() {
    it('saves the new file', async function() {
      const doc = builders
        .metafile()
        .path('new-file')
        .data('content')
        .tags('courge', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    context('remote', function() {
      context(
        'when an unsynced local file record with the same path but different content exists',
        () => {
          const filepath = 'BUZZ.JPG'

          beforeEach('create a file', async function() {
            await builders
              .metafile()
              .path(filepath)
              .data('local content')
              .sides({ local: 1 })
              .create()
          })

          it('creates a remote conflict', async function() {
            const newRemoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('remote content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            const doc = builders
              .metafile()
              .fromRemote(newRemoteFile)
              .unmerged('remote')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('remote', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: [
                ['remote', { path: filepath, remote: doc.remote }]
              ]
            })
          })
        }
      )

      context(
        'when an unsynced local file record with the same path and content exists',
        () => {
          const filepath = 'BUZZ.JPG'

          let file
          beforeEach('create a file', async function() {
            file = await builders
              .metafile()
              .path(filepath)
              .data('same content')
              .sides({ local: 1 })
              .create()
          })

          it('updates the record with the remote metadata', async function() {
            const newRemoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('same content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            const doc = builders
              .metafile()
              .fromRemote(newRemoteFile)
              .unmerged('remote')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('remote', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    mime: doc.mime,
                    class: doc.class,
                    tags: ['foo'],
                    executable: doc.executable,
                    updated_at: doc.updated_at,
                    sides: {
                      local: file.sides.local,
                      remote: file.sides.target + 1,
                      target: file.sides.target + 1
                    },
                    remote: doc.remote,
                    cozyMetadata: doc.cozyMetadata,
                    // FIXME: $FlowFixMe not part of Metadata but still saved in PouchDB
                    created_at: doc.created_at,
                    // FIXME: $FlowFixMe not part of Metadata but still saved in PouchDB
                    dir_id: doc.dir_id,
                    // FIXME: $FlowFixMe not part of Metadata but still saved in PouchDB
                    name: doc.name
                  },
                  _.omit(file, ['_id', '_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when a deleted local file record with the same path but different content exists',
        () => {
          const filepath = 'BUZZ.JPG'

          let synced, file
          beforeEach('create a file', async function() {
            const remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('initial content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            synced = await builders
              .metafile()
              .fromRemote(remoteFile)
              .upToDate()
              .create()
            file = await builders
              .metafile(synced)
              .deleted()
              .changedSide('local')
              .create()
          })

          it('overwrites the existing record', async function() {
            const newRemoteFile = await builders
              // $FlowFixMe: synced.remote has the right type but Flow can't know it
              .remoteFile(synced.remote)
              .data('updated content')
              .build()
            const doc = builders
              .metafile()
              .fromRemote(newRemoteFile)
              .unmerged('remote')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('remote', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    overwrite: file,
                    sides: {
                      remote: 1,
                      target: 1
                    }
                  },
                  _.omit(doc, ['_id', '_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when an up-to-date file record with the same path exists',
        () => {
          const filepath = 'BUZZ.JPG'

          let file
          beforeEach('create a file', async function() {
            file = await builders
              .metafile()
              .path(filepath)
              .data('initial content')
              .ino(123)
              .upToDate()
              .create()
          })

          it('updates the existing record', async function() {
            const newRemoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('new content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            const doc = builders
              .metafile()
              .fromRemote(newRemoteFile)
              .unmerged('remote')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('remote', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    md5sum: doc.md5sum,
                    size: doc.size,
                    mime: doc.mime,
                    class: doc.class,
                    executable: doc.executable,
                    tags: doc.tags,
                    updated_at: doc.updated_at,
                    overwrite: file,
                    sides: increasedSides(file.sides, 'remote', 1),
                    remote: doc.remote,
                    cozyMetadata: doc.cozyMetadata,
                    // FIXME: $FlowFixMe not part of Metadata but still saved in PouchDB
                    created_at: doc.created_at,
                    // FIXME: $FlowFixMe not part of Metadata but still saved in PouchDB
                    dir_id: doc.dir_id,
                    // FIXME: $FlowFixMe not part of Metadata but still saved in PouchDB
                    name: doc.name
                  },
                  _.omit(file, ['_id', '_rev', 'fileid'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )
    })

    context('local', function() {
      const filepath = 'BUZZ.JPG'

      context(
        'when an unsynced remote file record with the same path but different content exists',
        () => {
          let file
          beforeEach('create a file', async function() {
            const remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('remote content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            file = await builders
              .metafile()
              .fromRemote(remoteFile)
              .sides({ remote: 1 })
              .create()
          })

          it('creates a local conflict', async function() {
            const doc = await builders
              .metafile()
              .path(filepath)
              .data('local content')
              .ino(123)
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: [
                ['local', { path: filepath, remote: file.remote }]
              ]
            })
          })
        }
      )

      context(
        'when an unsynced remote file record with the same path and content exists',
        () => {
          let file
          beforeEach('create a file', async function() {
            const remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('same content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            file = await builders
              .metafile()
              .fromRemote(remoteFile)
              .sides({ remote: 1 })
              .create()
          })

          it('updates the record with the local metadata', async function() {
            const doc = await builders
              .metafile()
              .path(filepath)
              .data('same content')
              .ino(123)
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    ino: doc.ino,
                    executable:
                      process.platform === 'win32'
                        ? file.executable
                        : doc.executable,
                    mime: doc.mime,
                    class: doc.class,
                    updated_at: doc.updated_at,
                    sides: {
                      remote: file.sides.remote,
                      local: file.sides.target + 1,
                      target: file.sides.target + 1
                    },
                    local: doc.local
                  },
                  _.omit(file, ['_id', '_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when a deleted remote file record with the same path and content exists',
        () => {
          let synced
          beforeEach('create a file', async function() {
            const remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('same content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            synced = await builders
              .metafile()
              .fromRemote(remoteFile)
              .upToDate()
              .create()
            await builders
              .metafile(synced)
              .deleted()
              .changedSide('remote')
              .create()
          })

          it('does not overwrite the existing record', async function() {
            const doc = await builders
              .metafile(synced)
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when a deleted remote file record with the same path but different content exists',
        () => {
          let synced, file
          beforeEach('create a file', async function() {
            const remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('remote content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            synced = await builders
              .metafile()
              .fromRemote(remoteFile)
              .upToDate()
              .create()
            file = await builders
              .metafile(synced)
              .deleted()
              .changedSide('remote')
              .create()
          })

          it('overwrites the existing record', async function() {
            const doc = await builders
              .metafile(synced)
              .data('local content')
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    overwrite: file,
                    sides: {
                      local: 1,
                      target: 1
                    }
                  },
                  _.omit(doc, ['_id', '_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when an up-to-date file record with the same path exists',
        () => {
          let file
          beforeEach('create a file', async function() {
            file = await builders
              .metafile()
              .path(filepath)
              .data('initial content')
              .ino(123)
              .upToDate()
              .create()
          })

          it('updates the existing record', async function() {
            const doc = builders
              .metafile()
              .path(filepath)
              .data('new content')
              .ino(456)
              .updatedAt(new Date())
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    ino: doc.ino,
                    md5sum: doc.md5sum,
                    size: doc.size,
                    updated_at: doc.updated_at,
                    sides: increasedSides(file.sides, 'local', 1),
                    overwrite: file,
                    local: doc.local
                  },
                  _.omit(file, ['_id', '_rev', 'fileid'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )
    })

    context('when the path was used in the past', function() {
      const path = 'file-created-deleted-and-then-recreated'

      beforeEach(async function() {
        const was = await builders
          .metafile()
          .path(path)
          .data('content')
          .create()
        await this.pouch.remove(was)
      })

      it('saves the new file with the correct side number', async function() {
        const doc = builders
          .metafile()
          .path(path)
          .data('file content')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { target: 1, [this.side]: 1 }
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('resolves an identity conflict with an existing file', async function() {
        await builders
          .metafile()
          .path('bar')
          .upToDate()
          .create()
        const doc = builders
          .metafile()
          .path('BAR')
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('remote', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [['remote', _.pick(doc, ['path', 'remote'])]]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not have identity conflicts', async function() {
        await builders
          .metafile()
          .path('bar')
          .upToDate()
          .create()
        const doc = builders
          .metafile()
          .path('BAR')
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('remote', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { target: 1, remote: 1 }
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('resolves a conflict with an existing dir', async function() {
      const existingLocalDir = await builders
        .metadir()
        .sides({ local: 1 })
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(existingLocalDir.path)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(newRemoteFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteFile, ['path', 'remote'])]
        ]
      })
    })

    it('does nothing for an already merged file (aka idempotence)', async function() {
      const mergedFile = await builders
        .metafile()
        .sides({ remote: 1 })
        .create()
      const sameFile = builders
        .metafile(mergedFile)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('updates the local metadata only when it has changed', async function() {
      const mergedFile = await builders
        .metafile()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .create()
      const sameFile = builders
        .metafile(mergedFile)
        .updatedAt(new Date())
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('local', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFile.local
            },
            _.omit(mergedFile, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('sets the local metadata when it is missing', async function() {
      const mergedFile = await builders
        .metafile()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .noLocal()
        .create()
      const sameFile = builders
        .metafile(mergedFile)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('local', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFile.local
            },
            _.omit(mergedFile, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps an existing local metadata when it is not present in the new doc', async function() {
      const oldRemoteFile = await builders
        .remoteFile()
        .updatedAt(2020, 5, 19, 11, 9, 0)
        .build()
      const mergedFile = await builders
        .metafile()
        .fromRemote(oldRemoteFile)
        .upToDate()
        .create()
      const newRemoteFile = await builders.remoteFile(oldRemoteFile).build()
      const sameFile = builders
        .metafile()
        .fromRemote(newRemoteFile)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              sides: increasedSides(mergedFile.sides, 'remote', 1),
              local: mergedFile.local
            },
            _.omit(sameFile, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatform('win32', () => {
      describe('for an existing file without fileid', () => {
        let existingFile
        beforeEach(async () => {
          existingFile = await builders
            .metafile()
            .upToDate()
            .ino(1)
            .noFileid()
            .create()
        })

        context('when new local file metadata has a fileid', () => {
          let sameFile
          beforeEach(() => {
            sameFile = builders
              .metafile(existingFile)
              .ino(1)
              .unmerged('local')
              .build()
          })

          it('migrates the existing file', async function() {
            await this.merge.addFileAsync('local', _.cloneDeep(sameFile))

            const savedFile = await this.pouch.bySyncedPath(existingFile.path)
            should(savedFile).have.properties({ fileid: sameFile.fileid })
          })

          for (const side of ['local', 'both']) {
            context(`when existing file has ${side} side`, () => {
              beforeEach(async () => {
                const sides =
                  side === 'both' ? { local: 2, remote: 2 } : { [side]: 1 }
                existingFile = await builders
                  .metafile(existingFile)
                  .sides(sides)
                  .create()
                sameFile = builders
                  .metafile(existingFile)
                  .ino(1)
                  .unmerged('local')
                  .build()
              })

              it(`migrates local side`, async function() {
                await this.merge.addFileAsync('local', _.cloneDeep(sameFile))

                const expectedSides =
                  side === 'both'
                    ? {
                        target: existingFile.sides.target + 1,
                        local: existingFile.sides.local + 1,
                        remote: existingFile.sides.remote
                      }
                    : {
                        target: existingFile.sides.target + 1,
                        local: existingFile.sides.local + 1
                      }
                const savedFile = await this.pouch.bySyncedPath(
                  existingFile.path
                )
                should(savedFile).have.properties({ sides: expectedSides })
              })
            })
          }
        })

        context('when new file does not have a fileid', () => {
          let sameFile
          beforeEach(() => {
            sameFile = builders
              .metafile(existingFile)
              .unmerged('local')
              .build()
          })

          it('does not migrate the existing file', async function() {
            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(sameFile))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: []
            })
          })
        })
      })

      describe('for an existing file with fileid', () => {
        let existingFile
        beforeEach(async () => {
          existingFile = await builders
            .metafile()
            .upToDate()
            .ino(1)
            .create()
        })

        it('does not migrate the existing file', async function() {
          const sameFile = builders
            .metafile(existingFile)
            .unmerged('local')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.addFileAsync('local', _.cloneDeep(sameFile))
          )

          should(sideEffects).deepEqual({
            savedDocs: [],
            resolvedConflicts: []
          })
        })
      })
    })

    context('on initial scan', function() {
      it('overrides an unsynced local addition with a local update', async function() {
        const initialFile = await builders
          .metafile()
          .sides({ local: 1 })
          .ino(123)
          .noRemote()
          .data('initial content')
          .create()
        const offlineUpdate = await builders
          .metafile(initialFile)
          .data('offline update')
          .newerThan(initialFile)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(offlineUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(initialFile.sides, 'local', 1),
                overwrite: initialFile
              },
              _.omit(offlineUpdate, ['_id', '_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('overrides an unsynced local update with a new one', async function() {
        const initial = await builders
          .metafile()
          .path('yafile')
          .sides({ local: 1 })
          .ino(37)
          .data('initial content')
          .create()
        const synced = await builders
          .metafile(initial)
          .upToDate()
          .create()
        const firstUpdate = await builders
          .metafile(synced)
          .changedSide('local')
          .data('first update')
          .create()
        const secondUpdate = builders
          .metafile(firstUpdate)
          .data('second update')
          .newerThan(firstUpdate)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(secondUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                sides: increasedSides(firstUpdate.sides, 'local', 1),
                overwrite: firstUpdate,
                remote: synced.remote
              },
              _.omit(secondUpdate, ['_id', '_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not overwrite an unsynced remote update with a locally unchanged file', async function() {
        const synced = await builders
          .metafile()
          .data('previous content')
          .upToDate()
          .create()
        await builders
          .metafile(synced)
          .overwrite(synced)
          .data('remote update')
          .changedSide('remote')
          .create()
        const sameAsSynced = builders
          .metafile(synced)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(sameAsSynced))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })

      it('does not overwrite an unsynced remote update with a locally updated file and creates a local conflict', async function() {
        const synced = await builders
          .metafile()
          .data('initial content')
          .upToDate()
          .create()
        const remoteUpdate = await builders
          .metafile(synced)
          .overwrite(synced)
          .data('remote update')
          .changedSide('remote')
          .create()
        const localUpdate = builders
          .metafile(synced)
          .data('local update')
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(localUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: {
                  remote: remoteUpdate.sides.remote + 1,
                  target: remoteUpdate.sides.target + 1
                }
              },
              _.omit(remoteUpdate, ['_id', '_rev', 'local'])
            )
          ],
          resolvedConflicts: [
            ['local', { path: localUpdate.path, remote: remoteUpdate.remote }]
          ]
        })
      })
    })
  })

  describe('updateFile', () => {
    let file

    beforeEach('create synced file', async function() {
      file = await builders
        .metafile()
        .path('FIZZBUZZ.JPG')
        .ino(3456)
        .data('image')
        .type('image/jpeg')
        .tags('foo')
        .upToDate()
        .updatedAt(new Date(2020, 5, 17, 15, 33, 30, 0)) // Necessary for date change tests
        .create()
    })

    it('creates the file if it does not exist', async function() {
      const doc = builders
        .metafile()
        .path('NEW-FILE')
        .data('content')
        .tags('courge', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    it('updates the remote metadata when content is the same', async function() {
      const doc = builders
        .metafile(file)
        .tags('bar', 'baz')
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        // Tags are only coming from the Cozy so we should not expect any tags
        // update coming from the local side.
        this.merge.updateFileAsync('remote', _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(file.sides, 'remote', 1),
              local: file.local
            },
            _.omit(doc, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('updates the local metadata when content is the same', async function() {
      const doc = builders
        .metafile(file)
        .updatedAt(new Date())
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: doc.local
            },
            _.omit(file, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('sets the local metadata when it is missing', async function() {
      const mergedFile = await builders
        .metafile()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .noLocal()
        .create()
      const sameFile = builders
        .metafile(mergedFile)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFile.local
            },
            _.omit(mergedFile, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps an existing local metadata when it is not present in the new doc', async function() {
      const initial = await builders
        .metafile()
        .data('initial content')
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .create()
      const update = builders
        .metafile(initial)
        .data('updated content')
        .updatedAt(new Date())
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('remote', _.cloneDeep(update))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              sides: increasedSides(initial.sides, 'remote', 1),
              local: initial.local,
              overwrite: initial
            },
            _.omit(update, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('overwrites the content when it was changed', async function() {
      const doc = builders
        .metafile(file)
        .data('new content')
        .tags('qux', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(file.sides, this.side, 1),
              overwrite: file,
              [otherSide(this.side)]: file[otherSide(this.side)]
            },
            _.omit(doc, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('rejects an unresolvable conflict with an existing directory', async function() {
      // FIXME: Why don't we resolve the conflict like everywhere else?
      const existingLocalDir = await builders
        .metadir()
        .sides({ local: 1 })
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(existingLocalDir.path)
        .unmerged('remote')
        .build()

      await should(
        this.merge.updateFileAsync('local', _.cloneDeep(newRemoteFile))
      ).be.rejectedWith(/conflict/)
    })

    it('resolves a conflict between a new remote update and a previous local version', async function() {
      const initial = await builders
        .metafile()
        .sides({ local: 1 })
        .ino(456)
        .data('initial content')
        .create()
      const synced = await builders
        .metafile(initial)
        .upToDate()
        .create()
      const mergedLocalUpdate = await builders
        .metafile(synced)
        .changedSide('local')
        .data('local update')
        .create()
      const newRemoteUpdate = builders
        .metafile(synced)
        .data('remote update')
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('remote', _.cloneDeep(newRemoteUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: {
                target: mergedLocalUpdate.sides.target + 1,
                local: mergedLocalUpdate.sides.local + 1
              }
            },
            // We're dissociating the local doc from the remote doc
            _.omit(mergedLocalUpdate, ['_id', '_rev', 'fileid', 'remote'])
          )
        ],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteUpdate, ['path', 'remote'])]
        ]
      })
    })

    it('does not overwrite an unsynced remote update with a locally unchanged file', async function() {
      const synced = await builders
        .metafile()
        .data('initial content')
        .upToDate()
        .create()
      await builders
        .metafile(synced)
        .overwrite(synced)
        .data('remote update')
        .changedSide('remote')
        .create()
      const unchangedLocal = builders
        .metafile(synced)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(unchangedLocal))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('does not overwrite an unsynced remote update with a locally updated file and creates a local conflict', async function() {
      const synced = await builders
        .metafile()
        .data('initial content')
        .upToDate()
        .create()
      const remoteUpdate = await builders
        .metafile(synced)
        .overwrite(synced)
        .data('remote update')
        .changedSide('remote')
        .create()
      const newLocalUpdate = builders
        .metafile(synced)
        .data('local update')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(newLocalUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: {
                remote: remoteUpdate.sides.remote + 1,
                target: remoteUpdate.sides.remote + 1
              }
            },
            _.omit(remoteUpdate, ['_id', '_rev', 'local'])
          )
        ],
        resolvedConflicts: [
          ['local', { path: newLocalUpdate.path, remote: remoteUpdate.remote }]
        ]
      })
    })

    it('does nothing when existing file is up to date', async function() {
      const initial = await builders
        .metafile()
        .sides({ [this.side]: 1 })
        .data('initial content')
        .create()
      const initialSynced = await builders
        .metafile(initial)
        .upToDate()
        .create()
      const update = await builders
        .metafile(initialSynced)
        .changedSide('local')
        .data('updated content')
        .create()
      const updateSynced = await builders
        .metafile(update)
        .updatedAt(new Date(2020, 5, 12, 10, 15, 0))
        .upToDate()
        .create()
      const sameUpdate = builders
        .metafile(updateSynced)
        .updatedAt(new Date())
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(sameUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              [this.side]: sameUpdate[this.side]
            },
            _.omit(updateSynced, ['_id', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('creates a conflict when the file is a CozyÂ Note export', async function() {
      const remoteNote = await builders
        .remoteNote()
        .name('my-note.cozy-note')
        .data('initial content')
        .create()
      const synced = await builders
        .metafile()
        .fromRemote(remoteNote)
        .upToDate()
        .create()
      const localUpdate = builders
        .metafile(synced)
        .data('local update')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(localUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              _deleted: true
            },
            _.omit(synced, ['_id', '_rev', 'sides', 'local', 'remote'])
          ),
          _.defaults(
            {
              sides: { target: 1, local: 1 },
              metadata: {}
            },
            _.omit(localUpdate, ['_id', '_rev'])
          )
        ],
        resolvedConflicts: [['remote', { path: synced.path }]]
      })
    })
  })

  describe('putFolder', () => {
    it('saves the new folder', async function() {
      const doc = builders
        .metadir()
        .path('NEW-FOLDER')
        .tags('courge', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    it('saves a new version of an existing folder', async function() {
      const old = await builders
        .metadir()
        .path('existing-folder')
        .upToDate()
        .create()
      const doc = builders
        .metadir(old)
        .whateverChange()
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(old.sides, this.side, 1),
              [otherSide(this.side)]: old[otherSide(this.side)]
            },
            _.omit(doc, ['_id', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the path was used in the past', function() {
      const path = 'folder-created-deleted-and-then-recreated'

      beforeEach(async function() {
        const was = await builders
          .metadir()
          .path(path)
          .sides({ [this.side]: 1 })
          .create()
        await this.pouch.remove(was)
      })

      it('saves the new folder with the correct side number', async function() {
        const doc = builders
          .metadir()
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { target: 1, [this.side]: 1 }
              },
              _.omit(doc, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('does nothing when existing folder is up to date', async function() {
      const old = await builders
        .metadir()
        .path('up-to-date-folder')
        .upToDate()
        .create()
      const doc = builders
        .metadir(old)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('resolves a conflict with an existing file', async function() {
      const existingLocalFile = await builders
        .metafile()
        .sides({ local: 1 })
        .create()
      const newRemoteDir = builders
        .metadir()
        .path(existingLocalFile.path)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('remote', _.cloneDeep(newRemoteDir))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteDir, ['path', 'remote'])]
        ]
      })
    })

    it('updates the local metadata only when it has changed', async function() {
      const mergedFolder = await builders
        .metadir()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .create()
      const sameFolder = builders
        .metadir(mergedFolder)
        .updatedAt(new Date())
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('local', _.cloneDeep(sameFolder))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFolder.local
            },
            _.omit(mergedFolder, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('sets the local metadata when it is missing', async function() {
      const mergedFolder = await builders
        .metadir()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .noLocal()
        .create()
      const sameFolder = builders
        .metadir(mergedFolder)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('local', _.cloneDeep(sameFolder))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: sameFolder.local
            },
            _.omit(mergedFolder, ['_id', '_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps an existing local metadata when it is not present in the new doc', async function() {
      const oldRemoteDir = await builders
        .remoteDir()
        .updatedAt(2020, 5, 19, 11, 9, 0)
        .build()
      const mergedFolder = await builders
        .metadir()
        .fromRemote(oldRemoteDir)
        .upToDate()
        .create()
      const newRemoteDir = await builders.remoteDir(oldRemoteDir).build()
      const sameFolder = builders
        .metadir()
        .fromRemote(newRemoteDir)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('remote', _.cloneDeep(sameFolder))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              sides: increasedSides(mergedFolder.sides, 'remote', 1),
              local: mergedFolder.local
            },
            _.omit(sameFolder, ['_rev', 'fileid'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context(
      'when doc can have an identity conflict with an existing dir',
      () => {
        let Alfred

        beforeEach(async function() {
          await builders
            .metadir()
            .path('alfred')
            .sides({ [otherSide(this.side)]: 1 })
            .create()
          Alfred = await builders
            .metadir()
            .path('Alfred')
            .unmerged(this.side)
            .build()
        })

        onPlatforms(['win32', 'darwin'], () => {
          it('resolves the conflict', async function() {
            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.putFolderAsync(this.side, _.cloneDeep(Alfred))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: [
                [this.side, _.pick(Alfred, ['path', 'remote'])]
              ]
            })
          })
        })

        onPlatform('linux', () => {
          it('saves the doc as a new doc', async function() {
            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.putFolderAsync(this.side, _.cloneDeep(Alfred))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaultsDeep(
                  {
                    sides: { target: 1, [this.side]: 1 }
                  },
                  Alfred
                )
              ],
              resolvedConflicts: []
            })
          })
        })
      }
    )
  })

  describe('moveFileAsync', function() {
    beforeEach('create parent folder', async function() {
      await builders
        .metadir()
        .path('FOO')
        .upToDate()
        .create()
    })

    context('local', () => {
      it('saves the new file and deletes the old one with move hints for writers', async function() {
        const was = await builders
          .metafile()
          .path('FOO/OLD')
          .ino(1)
          .upToDate()
          .data('content')
          .tags('courge', 'quux')
          .create()
        const doc = builders
          .metafile(was)
          .path('FOO/NEW')
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev', 'fileid']),
            _.defaultsDeep(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)],
                ino: was.ino
              },
              _.omit(doc, ['_id', '_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('remote', () => {
      it('saves the new file and deletes the old one with move hints for writers', async function() {
        const oldRemoteFile = await builders
          .remoteFile()
          .inRootDir()
          .name('OLD')
          .data('content')
          .shortRev(1)
          .build()
        const was = await builders
          .metafile()
          .fromRemote(oldRemoteFile)
          .ino(1)
          .upToDate()
          .create()
        const newRemoteFile = await builders
          .remoteFile(oldRemoteFile)
          .name('NEW')
          .shortRev(2)
          .build()
        const doc = builders
          .metafile()
          .fromRemote(newRemoteFile)
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev', 'fileid']),
            _.defaultsDeep(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [this.side]: was[this.side],
                ino: was.ino
              },
              _.omit(doc, ['_id', '_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('adds missing fields', async function() {
      const was = await builders
        .metafile()
        .path('FOO/OLD-MISSING-FIELDS.JPG')
        .ino(3854)
        .data('image')
        .type('image/jpeg')
        .tags('courge', 'quux')
        .upToDate()
        .create()
      const doc = builders
        .metafile(was)
        .path('FOO/NEW-MISSING-FIELDS.JPG')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc.path,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_id', '_rev', 'fileid']),
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: movedSrc,
              [otherSide(this.side)]: was[otherSide(this.side)]
            },
            _.omit(doc, ['fileid', '_id'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the destination exists', () => {
      let existing

      beforeEach(async function() {
        existing = await builders
          .metafile()
          .path('DST_FILE')
          .updatedAt(new Date(2020, 5, 19, 12, 12, 0))
          .upToDate()
          .create()
      })

      it('overrides the existing destination document', async function() {
        const was = await builders
          .metafile()
          .path('SRC_FILE')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path(existing.path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaultsDeep(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                path: doc.path,
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                overwrite: existing,
                [this.side]: doc[this.side]
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      context('and we have unapplied modifications on the other side', () => {
        beforeEach(async function() {
          existing = await builders
            .metafile(existing)
            .data('new content')
            .changedSide('remote')
            .create()
        })

        it('resolves a conflict', async function() {
          const was = await builders
            .metafile()
            .path('SRC_FILE')
            .upToDate()
            .create()
          const doc = builders
            .metafile(was)
            .path(existing.path)
            .unmerged('local')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFileAsync(
              'local',
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const { path: dstPath } = _.find(sideEffects.savedDocs, ({ path }) =>
            path.match(/conflict/)
          )

          const movedSrc = _.defaults(
            {
              moveTo: dstPath,
              _deleted: true
            },
            was
          )
          should(sideEffects).deepEqual({
            savedDocs: [
              _.omit(movedSrc, ['_id', '_rev']),
              _.defaultsDeep(
                {
                  path: dstPath,
                  sides: increasedSides(was.sides, 'local', 1),
                  moveFrom: movedSrc,
                  local: { path: dstPath },
                  remote: was.remote
                },
                _.omit(doc, ['_id'])
              )
            ],
            resolvedConflicts: [
              ['local', { path: doc.path, remote: was.remote }]
            ]
          })
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_FILE'

      beforeEach(async function() {
        const previous = await builders
          .metafile()
          .path(path)
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new file with the correct side', async function() {
        const was = await builders
          .metafile()
          .path('SRC_FILE')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              _.omit(doc, ['_id'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('replaces a local move with an addition for a local-only file', async function() {
      const was = await builders
        .metafile()
        .path('FOO/OLD')
        .data('content')
        .tags('courge', 'quux')
        .sides({ local: 1 })
        .create()
      const doc = builders
        .metafile(was)
        .path('FOO/NEW')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('local', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const unsyncedFile = _.defaults(
        {
          _deleted: true
        },
        _.omit(was, ['_id', '_rev', 'sides', 'local', 'remote'])
      )
      const fileAddition = _.defaults(
        {
          sides: { target: 1, local: 1 }
        },
        _.omit(doc, ['_id'])
      )
      should(sideEffects).deepEqual({
        savedDocs: [unsyncedFile, fileAddition],
        resolvedConflicts: []
      })
    })

    it('replaces a remote move with an addition for a remote-only file', async function() {
      const oldRemoteFile = builders
        .remoteFile()
        .inRootDir()
        .name('OLD')
        .data('content')
        .build()
      const was = await builders
        .metafile()
        .fromRemote(oldRemoteFile)
        .sides({ remote: 1 })
        .create()
      const newRemoteFile = builders
        .remoteFile(oldRemoteFile)
        .name('NEW')
        .build()
      const doc = builders
        .metafile()
        .fromRemote(newRemoteFile)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('remote', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const unsyncedFile = _.defaults(
        {
          _deleted: true
        },
        _.omit(was, ['_id', '_rev', 'sides', 'local', 'remote'])
      )
      const fileAddition = _.defaults(
        {
          sides: { target: 1, remote: 1 }
        },
        doc
      )
      should(sideEffects).deepEqual({
        savedDocs: [unsyncedFile, fileAddition],
        resolvedConflicts: []
      })
    })

    it('does not identify the child move of a file following another unsynced move as an addition', async function() {
      const src = await builders
        .metadir()
        .path('SRC')
        .upToDate()
        .create()
      const file = await builders
        .metafile()
        .path('SRC/FILE')
        .upToDate()
        .create()
      const file2 = builders
        .metafile(file)
        .path('SRC/FILE2')
        .unmerged('local')
        .build()
      await this.merge.moveFileAsync(
        'local',
        _.cloneDeep(file2),
        _.cloneDeep(file)
      )
      const was = await this.pouch.bySyncedPath(file2.path)
      const dst = builders
        .metadir(src)
        .path('DST')
        .unmerged('local')
        .build()
      const doc = await builders
        .metafile(was)
        .path('DST/FILE2')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync('local', _.cloneDeep(dst), _.cloneDeep(src))
      )

      const movedSrc = _.defaults(
        {
          moveTo: dst.path,
          _deleted: true
        },
        src
      )
      const movedFile = _.defaults(
        {
          moveTo: doc.path,
          childMove: true,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_id', '_rev']),
          _.defaults(
            {
              sides: increasedSides(src.sides, this.side, 1),
              moveFrom: movedSrc,
              remote: src.remote
            },
            _.omit(dst, ['_id', '_rev'])
          ),
          _.omit(movedFile, ['_id', '_rev']),
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: movedFile,
              remote: was.remote
            },
            _.omit(doc, ['_id', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('does not identify the local move of a file following an unsynced child move as an addition', async function() {
      const src = await builders
        .metadir()
        .path('SRC')
        .upToDate()
        .create()
      await builders
        .metafile()
        .path('SRC/FILE')
        .upToDate()
        .create()
      const dst = builders
        .metadir(src)
        .path('DST')
        .unmerged('local')
        .build()
      await this.merge.moveFolderAsync(
        'local',
        _.cloneDeep(dst),
        _.cloneDeep(src)
      )
      const was = await this.pouch.bySyncedPath(path.normalize('DST/FILE'))
      const doc = await builders
        .metafile(was)
        .path('DST/FILE2')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('local', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc.path,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_id', '_rev']),
          _.defaults(
            {
              sides: increasedSides(was.sides, 'local', 1),
              moveFrom: movedSrc,
              remote: was.remote
            },
            _.omit(doc, ['_id', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const banana = await builders
          .metafile()
          .path('banana')
          .upToDate()
          .create()
        const BANANA = builders
          .metafile(banana)
          .path('BANANA')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(BANANA),
            _.cloneDeep(banana)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                moveTo: BANANA.path,
                _deleted: true
              },
              _.omit(banana, ['_id', '_rev'])
            ),
            _.defaultsDeep(
              {
                sides: increasedSides(banana.sides, this.side, 1),
                path: BANANA.path,
                moveFrom: _.defaults(
                  {
                    moveTo: BANANA.path,
                    _deleted: true
                  },
                  banana
                ),
                [this.side]: BANANA[this.side]
              },
              _.omit(banana, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('resolves an identity conflict with an existing file', async function() {
        await builders
          .metafile()
          .path('QUX')
          .create()
        const was = await builders
          .metafile()
          .path('baz')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path('qux')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            [this.side, { path: doc.path, remote: was.remote }]
          ]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const banana = await builders
          .metafile()
          .path('banana')
          .upToDate()
          .create()
        const BANANA = builders
          .metafile(banana)
          .path('BANANA')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(BANANA),
            _.cloneDeep(banana)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: BANANA.path,
            _deleted: true
          },
          banana
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(banana.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: banana[otherSide(this.side)]
              },
              _.omit(BANANA, ['_id'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not have identity conflicts', async function() {
        const was = await builders
          .metafile()
          .path('baz')
          .upToDate()
          .create()
        await builders
          .metafile()
          .path('QUX')
          .create()
        const doc = builders
          .metafile(was)
          .path('qux')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              _.omit(doc, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('moveFolderAsync', function() {
    context('local', () => {
      it('saves the new folder and deletes the old one with hints for writers', async function() {
        const was = await builders
          .metadir()
          .path('OLD')
          .ino(666)
          .tags('courge', 'quux')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path('NEW')
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            'local',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev', 'fileid']),
            _.defaults(
              {
                sides: increasedSides(was.sides, 'local', 1),
                moveFrom: movedSrc,
                remote: was.remote
              },
              _.omit(doc, ['_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })

      context('when the folder does not exist remotely', () => {
        it('saves a local folder addition', async function() {
          const was = await builders
            .metadir()
            .path('OLD')
            .ino(666)
            .tags('courge', 'quux')
            .sides({ local: 1 })
            .create()
          const doc = builders
            .metadir(was)
            .path('NEW')
            .tags('courge', 'quux')
            .unmerged('local')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              'local',
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const unsyncedFolder = _.defaults(
            {
              _deleted: true
            },
            _.omit(was, ['_id', '_rev', 'fileid', 'sides', 'local', 'remote'])
          )
          const folderAddition = _.defaults(
            {
              sides: { target: 1, local: 1 }
            },
            _.omit(doc, ['_id', '_rev', 'fileid'])
          )
          should(sideEffects).deepEqual({
            savedDocs: [unsyncedFolder, folderAddition],
            resolvedConflicts: []
          })
        })
      })
    })

    context('remote', () => {
      it('saves the new folder and deletes the old one with hints for writers', async function() {
        const oldRemoteDir = builders
          .remoteDir()
          .inRootDir()
          .name('OLD')
          .build()
        const was = await builders
          .metadir()
          .fromRemote(oldRemoteDir)
          .ino(666)
          .upToDate()
          .create()
        const newRemoteDir = builders
          .remoteDir(oldRemoteDir)
          .inRootDir()
          .name('NEW')
          .build()
        const doc = builders
          .metadir()
          .fromRemote(newRemoteDir)
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            'remote',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev', 'fileid']),
            _.defaults(
              {
                sides: increasedSides(was.sides, 'remote', 1),
                moveFrom: movedSrc,
                local: was.local,
                ino: was.ino
              },
              _.omit(doc, ['_rev', 'fileid'])
            )
          ],
          resolvedConflicts: []
        })
      })

      context('when the folder does not exist locally', () => {
        it('saves a remote folder addition', async function() {
          const oldRemoteDir = builders
            .remoteDir()
            .inRootDir()
            .name('OLD')
            .build()
          const was = await builders
            .metadir()
            .fromRemote(oldRemoteDir)
            .sides({ remote: 1 })
            .create()
          const newRemoteDir = builders
            .remoteDir(oldRemoteDir)
            .name('NEW')
            .build()
          const doc = builders
            .metadir()
            .fromRemote(newRemoteDir)
            .unmerged('remote')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              'remote',
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const unsyncedFolder = _.defaults(
            {
              _deleted: true
            },
            _.omit(was, ['_id', '_rev', 'fileid', 'sides', 'local', 'remote'])
          )
          const folderAddition = _.defaults(
            {
              sides: { target: 1, remote: 1 }
            },
            _.omit(doc, ['_id', '_rev', 'fileid'])
          )
          should(sideEffects).deepEqual({
            savedDocs: [unsyncedFolder, folderAddition],
            resolvedConflicts: []
          })
        })
      })
    })

    context('when the destination exists', () => {
      let existing

      context('and it is up-to-date', () => {
        beforeEach(async function() {
          existing = await builders
            .metadir()
            .path('DST_DIR')
            .upToDate()
            .create()
        })

        it('overwrites the destination', async function() {
          const was = await builders
            .metadir()
            .path('SRC_DIR')
            .upToDate()
            .create()
          const doc = builders
            .metadir(was)
            .path(existing.path)
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              this.side,
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const movedSrc = _.defaults(
            {
              moveTo: existing.path,
              _deleted: true
            },
            was
          )
          should(sideEffects).deepEqual({
            savedDocs: [
              _.omit(movedSrc, ['_id', '_rev']),
              _.defaults(
                {
                  path: existing.path,
                  sides: increasedSides(was.sides, this.side, 1),
                  moveFrom: movedSrc,
                  overwrite: existing,
                  [otherSide(this.side)]: was[otherSide(this.side)]
                },
                _.omit(doc, ['_id'])
              )
            ],
            resolvedConflicts: []
          })
        })
      })

      context('and it is not at least up-to-date on the movement side', () => {
        beforeEach(async function() {
          existing = await builders
            .metadir()
            .path('DST_DIR')
            .changedSide(otherSide(this.side))
            .create()
        })

        it('resolves a conflict', async function() {
          const was = await builders
            .metadir()
            .path('SRC_DIR')
            .upToDate()
            .create()
          const doc = builders
            .metadir(was)
            .path(existing.path)
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              this.side,
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const { path: dstPath } = _.find(sideEffects.savedDocs, ({ path }) =>
            path.match(/conflict/)
          )

          const movedSrc = _.defaults(
            {
              moveTo: dstPath,
              _deleted: true
            },
            was
          )
          should(sideEffects).deepEqual({
            savedDocs: [
              _.omit(movedSrc, ['_id', '_rev']),
              _.defaultsDeep(
                {
                  path: dstPath,
                  sides: increasedSides(was.sides, this.side, 1),
                  moveFrom: movedSrc,
                  [this.side]: { path: dstPath },
                  [otherSide(this.side)]: was[otherSide(this.side)]
                },
                _.omit(doc, ['_id'])
              )
            ],
            resolvedConflicts: [[this.side, _.pick(doc, ['path', 'remote'])]]
          })
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_DIR'

      beforeEach(async function() {
        const previous = await builders
          .metadir()
          .path(path)
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new directory with the correct side', async function() {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              _.omit(doc, ['_id'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('does not create conflict for local-only existing folder.', async function() {
      const existing = await builders
        .metadir()
        .path('DST_DIR')
        .sides({ [this.side]: 1 })
        .create()
      const was = await builders
        .metadir()
        .path('SRC_DIR')
        .upToDate()
        .create()
      const doc = builders
        .metadir(was)
        .path(existing.path)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(
          this.side,
          _.cloneDeep(doc),
          _.cloneDeep(was)
        )
      )

      const movedSrc = _.defaults(
        {
          moveTo: doc.path,
          _deleted: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrc, ['_id', '_rev']),
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: movedSrc,
              overwrite: existing,
              [otherSide(this.side)]: was[otherSide(this.side)]
            },
            _.omit(doc, ['_id'])
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const apple = await builders
          .metadir()
          .path('apple')
          .upToDate()
          .create()
        const APPLE = builders
          .metadir(apple)
          .path('APPLE')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(APPLE),
            _.cloneDeep(apple)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                moveTo: APPLE.path,
                _deleted: true
              },
              _.omit(apple, ['_id', '_rev'])
            ),
            _.defaultsDeep(
              {
                sides: increasedSides(apple.sides, this.side, 1),
                path: APPLE.path,
                moveFrom: _.defaults(
                  {
                    moveTo: APPLE.path,
                    _deleted: true
                  },
                  apple
                ),
                [this.side]: APPLE[this.side]
              },
              _.omit(apple, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('resolves an identity conflict when moving a synced folder to an existing path', async function() {
        await builders
          .metadir()
          .path('LINUX')
          .create()
        const torvalds = await builders
          .metadir()
          .path('torvalds')
          .upToDate()
          .create()
        const linux = builders
          .metadir(torvalds)
          .path('linux')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(linux),
            _.cloneDeep(torvalds)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [], // XXX: The conflict will be considered as a new change and merged later
          resolvedConflicts: [[this.side, _.pick(linux, ['path', 'remote'])]]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const apple = await builders
          .metadir()
          .path('apple')
          .upToDate()
          .create()
        const APPLE = builders
          .metadir(apple)
          .path('APPLE')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(APPLE),
            _.cloneDeep(apple)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: APPLE.path,
            _deleted: true
          },
          apple
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(apple.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: apple[otherSide(this.side)]
              },
              _.omit(APPLE, ['_id'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not have identity conflicts', async function() {
        await builders
          .metadir()
          .path('NUKEM')
          .create()
        const duke = await builders
          .metadir()
          .path('duke')
          .upToDate()
          .create()
        const nukem = builders
          .metadir(duke)
          .path('nukem')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(nukem),
            _.cloneDeep(duke)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: nukem.path,
            _deleted: true
          },
          duke
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(duke.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: duke[otherSide(this.side)]
              },
              _.omit(nukem, ['_id'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('handles overwritten descendants', async function() {
      const srcDir = await builders
        .metadir()
        .path('src')
        .upToDate()
        .create()
      const srcFile = await builders
        .metafile()
        .path('src/file')
        .upToDate()
        .create()
      const oldDst = await builders
        .metadir()
        .path('dst')
        .upToDate()
        .create()
      const oldDstFile = await builders
        .metafile()
        .path('dst/file')
        .upToDate()
        .create()
      const dstDir = builders
        .metadir(srcDir)
        .path('dst')
        .overwrite(oldDst)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(
          this.side,
          _.cloneDeep(dstDir),
          _.cloneDeep(srcDir)
        )
      )

      const movedSrcDir = _.defaults(
        {
          moveTo: dstDir.path,
          _deleted: true
        },
        srcDir
      )
      const movedSrcFile = _.defaults(
        {
          moveTo: oldDstFile.path,
          childMove: true,
          _deleted: true
        },
        srcFile
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedSrcDir, ['_id', '_rev']),
          _.defaults(
            {
              sides: increasedSides(srcDir.sides, this.side, 1),
              moveFrom: movedSrcDir,
              overwrite: oldDst,
              [otherSide(this.side)]: srcDir[otherSide(this.side)]
            },
            _.omit(dstDir, ['_id', '_rev'])
          ),
          _.omit(movedSrcFile, ['_id', '_rev']),
          _.defaultsDeep(
            {
              path: oldDstFile.path,
              sides: increasedSides(srcFile.sides, this.side, 1),
              moveFrom: movedSrcFile,
              overwrite: oldDstFile,
              [this.side]: { path: oldDstFile[this.side].path }
            },
            _.omit(srcFile, ['_id', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('moveFolderRecursively', function() {
    it('moves the folder and files/folders inside it', async function() {
      const was = await builders
        .metadir()
        .path('my-folder')
        .upToDate()
        .create()
      const subdir = await builders
        .metadir()
        .path('my-folder/folder-9')
        .upToDate()
        .create()
      const subfile = await builders
        .metafile()
        .path('my-folder/file-9')
        .upToDate()
        .create()
      const doc = builders
        .metadir(was)
        .path('DESTINATION')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderRecursivelyAsync(
          this.side,
          _.cloneDeep(doc),
          _.cloneDeep(was)
        )
      )

      const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

      const movedDir = _.defaults(
        {
          moveTo: doc.path,
          _deleted: true
        },
        was
      )
      const movedSubfile = _.defaults(
        {
          moveTo: movedPath(subfile),
          childMove: true,
          _deleted: true
        },
        subfile
      )
      const movedSubdir = _.defaults(
        {
          moveTo: movedPath(subdir),
          childMove: true,
          _deleted: true
        },
        subdir
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.omit(movedDir, ['_id', '_rev']),
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: movedDir,
              [otherSide(this.side)]: was[otherSide(this.side)]
            },
            _.omit(doc, ['_id', '_rev'])
          ),
          _.omit(movedSubfile, ['_id', '_rev']),
          _.defaultsDeep(
            {
              path: movedPath(subfile),
              sides: increasedSides(subfile.sides, this.side, 1),
              moveFrom: movedSubfile,
              [this.side]: { path: movedPath(subfile) },
              [otherSide(this.side)]: movedSubfile[otherSide(this.side)]
            },
            _.omit(subfile, ['_id', '_rev'])
          ),
          _.omit(movedSubdir, ['_id', '_rev']),
          _.defaultsDeep(
            {
              path: movedPath(subdir),
              sides: increasedSides(subdir.sides, this.side, 1),
              moveFrom: movedSubdir,
              [this.side]: { path: movedPath(subdir) },
              [otherSide(this.side)]: movedSubdir[otherSide(this.side)]
            },
            _.omit(subdir, ['_id', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context('local', () => {
      it('adds an unsynced remote file to the destination folder', async function() {
        const was = await builders
          .metadir()
          .path('ADDED_DIR')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path('MOVED_DIR')
          .unmerged('local')
          .build()
        const unsyncedRemoteFile = await builders
          .remoteFile()
          .inDir(was.remote)
          .name('unsynced-file')
          .build()
        const unsyncedFile = await builders
          .metafile()
          .fromRemote(unsyncedRemoteFile)
          .noLocal()
          .sides({ remote: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            'local',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, 'local', 1),
                moveFrom: movedSrc,
                remote: was.remote
              },
              _.omit(doc, ['_rev'])
            ),
            _.defaults(
              {
                _deleted: true
              },
              _.omit(unsyncedFile, ['_id', '_rev', 'sides', 'remote'])
            ),
            _.defaults(
              {
                path: movedPath(unsyncedFile),
                sides: { target: 1, remote: 1 }
              },
              _.omit(unsyncedFile, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('remote', () => {
      it('adds an unsynced local file to the destination folder', async function() {
        const oldRemoteDir = builders
          .remoteDir()
          .inRootDir()
          .name('ADDED_DIR')
          .build()
        const was = await builders
          .metadir()
          .fromRemote(oldRemoteDir)
          .upToDate()
          .create()
        const newRemoteDir = builders
          .remoteDir(oldRemoteDir)
          .name('MOVED_DIR')
          .build()
        const doc = builders
          .metadir()
          .fromRemote(newRemoteDir)
          .unmerged('remote')
          .build()
        const unsyncedFile = await builders
          .metafile()
          .path('ADDED_DIR/unsynced-file')
          .noRemote()
          .sides({ local: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            'remote',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, 'remote', 1),
                moveFrom: movedSrc,
                local: was.local
              },
              doc
            ),
            _.defaults(
              {
                _deleted: true
              },
              _.omit(unsyncedFile, ['_id', '_rev', 'sides', 'local'])
            ),
            _.defaults(
              {
                path: movedPath(unsyncedFile),
                sides: { target: 1, local: 1 }
              },
              _.omit(unsyncedFile, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_DIR'

      beforeEach(async function() {
        const previous = await builders
          .metadir()
          .path(path)
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new directory with the correct side', async function() {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedSrc = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedSrc, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedSrc,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              _.omit(doc, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when the destination of a child has existed', () => {
      const parentPath = 'DST_DIR'
      const childName = 'CHILD'

      beforeEach(async function() {
        const previous = await builders
          .metadata()
          .path(`${parentPath}/${childName}`)
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new child with the correct side', async function() {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const child = await builders
          .metadata()
          .path(`SRC_DIR/${childName}`)
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(parentPath)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        const movedDir = _.defaults(
          {
            moveTo: doc.path,
            _deleted: true
          },
          was
        )
        const movedChild = _.defaults(
          {
            moveTo: movedPath(child),
            childMove: true,
            _deleted: true
          },
          child
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.omit(movedDir, ['_id', '_rev']),
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: movedDir,
                [otherSide(this.side)]: was[otherSide(this.side)]
              },
              _.omit(doc, ['_id'])
            ),
            _.omit(movedChild, ['_id', '_rev']),
            _.defaultsDeep(
              {
                path: movedPath(child),
                sides: increasedSides(child.sides, this.side, 1),
                moveFrom: movedChild,
                [this.side]: { path: movedPath(child) }
              },
              _.omit(child, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    onPlatform('darwin', () => {
      context(
        'when the parent normalization differs in its children paths',
        () => {
          it('correctly replaces the NFD parent part in the children paths', async function() {
            const nfdParentPath = 'ÃnoncÃ©s'.normalize('NFD')
            const nfcParentPath = nfdParentPath.normalize('NFC')
            const was = await builders
              .metadir()
              .path(nfcParentPath)
              .upToDate()
              .create()
            const subdir = await builders
              .metadir()
              .path(path.join(nfdParentPath, 'folder-9'))
              .upToDate()
              .create()
            const subfile = await builders
              .metafile()
              .path(path.join(subdir.path, 'file-9'))
              .upToDate()
              .create()
            const doc = builders
              .metadir(was)
              .path('DESTINATION')
              .unmerged(this.side)
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.moveFolderRecursivelyAsync(
                this.side,
                _.cloneDeep(doc),
                _.cloneDeep(was)
              )
            )

            const movedDir = _.defaults(
              {
                moveTo: doc.path,
                _deleted: true
              },
              was
            )
            const movedSubdirPath = path.join(doc.path, 'folder-9')
            const movedSubdir = _.defaults(
              {
                moveTo: movedSubdirPath,
                childMove: true,
                _deleted: true
              },
              subdir
            )
            const movedSubfilePath = path.join(movedSubdirPath, 'file-9')
            const movedSubfile = _.defaultsDeep(
              {
                moveTo: movedSubfilePath,
                childMove: true,
                _deleted: true
              },
              subfile
            )
            should(sideEffects).deepEqual({
              savedDocs: [
                _.omit(movedDir, ['_id', '_rev']),
                _.defaults(
                  {
                    sides: increasedSides(was.sides, this.side, 1),
                    moveFrom: movedDir,
                    [otherSide(this.side)]: was[otherSide(this.side)]
                  },
                  _.omit(doc, ['_id', '_rev'])
                ),
                _.omit(movedSubdir, ['_id', '_rev']),
                _.defaultsDeep(
                  {
                    path: movedSubdirPath,
                    sides: increasedSides(subdir.sides, this.side, 1),
                    moveFrom: movedSubdir,
                    [this.side]: { path: movedSubdirPath }
                  },
                  _.omit(subdir, ['_id', '_rev'])
                ),
                _.omit(movedSubfile, ['_id', '_rev']),
                _.defaultsDeep(
                  {
                    path: movedSubfilePath,
                    sides: increasedSides(subfile.sides, this.side, 1),
                    moveFrom: movedSubfile,
                    [this.side]: { path: movedSubfilePath }
                  },
                  _.omit(subfile, ['_id', '_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })

          it('correctly replaces the NFC parent part in the children paths', async function() {
            const nfdParentPath = 'ÃnoncÃ©s'.normalize('NFD')
            const nfcParentPath = nfdParentPath.normalize('NFC')
            const was = await builders
              .metadir()
              .path(nfdParentPath)
              .upToDate()
              .create()
            const subdir = await builders
              .metadir()
              .path(path.join(nfcParentPath, 'folder-9'))
              .upToDate()
              .create()
            const subfile = await builders
              .metafile()
              .path(path.join(subdir.path, 'file-9'))
              .upToDate()
              .create()
            const doc = builders
              .metadir(was)
              .path('DESTINATION')
              .unmerged(this.side)
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.moveFolderRecursivelyAsync(
                this.side,
                _.cloneDeep(doc),
                _.cloneDeep(was)
              )
            )

            const movedDir = _.defaults(
              {
                moveTo: doc.path,
                _deleted: true
              },
              was
            )
            const movedSubdirPath = path.join(doc.path, 'folder-9')
            const movedSubdir = _.defaults(
              {
                moveTo: movedSubdirPath,
                childMove: true,
                _deleted: true
              },
              subdir
            )
            const movedSubfilePath = path.join(movedSubdirPath, 'file-9')
            const movedSubfile = _.defaults(
              {
                moveTo: movedSubfilePath,
                childMove: true,
                _deleted: true
              },
              subfile
            )
            should(sideEffects).deepEqual({
              savedDocs: [
                _.omit(movedDir, ['_id', '_rev']),
                _.defaults(
                  {
                    sides: increasedSides(was.sides, this.side, 1),
                    moveFrom: movedDir,
                    [otherSide(this.side)]: was[otherSide(this.side)]
                  },
                  _.omit(doc, ['_id', '_rev'])
                ),
                _.omit(movedSubdir, ['_id', '_rev']),
                _.defaultsDeep(
                  {
                    path: movedSubdirPath,
                    sides: increasedSides(subdir.sides, this.side, 1),
                    moveFrom: movedSubdir,
                    [this.side]: { path: movedSubdirPath }
                  },
                  _.omit(subdir, ['_id', '_rev'])
                ),
                _.omit(movedSubfile, ['_id', '_rev']),
                _.defaultsDeep(
                  {
                    path: movedSubfilePath,
                    sides: increasedSides(subfile.sides, this.side, 1),
                    moveFrom: movedSubfile,
                    [this.side]: { path: movedSubfilePath }
                  },
                  _.omit(subfile, ['_id', '_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )
    })
  })

  describe('trashFolderAsync', () => {
    it('does not trash a folder if the other side has added a new file in it', async function() {
      const was = await builders
        .metadir()
        .path('trashed-folder')
        .upToDate()
        .create()
      await builders
        .metafile()
        .path('trashed-folder/file')
        .sides({ [otherSide(this.side)]: 1 })
        .create()
      const doc = await builders
        .metadir(was)
        .path(`.cozy_trash/${was.path}`)
        .trashed()
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.trashFolderAsync(
          this.side,
          _.cloneDeep(was),
          _.cloneDeep(doc)
        )
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: {
                target: was.sides.target + 1,
                [otherSide(this.side)]: was.sides[otherSide(this.side)] + 1
              }
            },
            _.omit(was, ['trashed', this.side, '_id', '_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('deleteFileAsync', () => {
    context('when a record is found in Pouch', () => {
      it('deletes a file', async function() {
        const doc = await builders
          .metafile()
          .path('FILE')
          .data('content')
          .sides({ [this.side]: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('removes move hints', async function() {
        const old = await builders
          .metafile()
          .path('FILE')
          .moveTo('MOVED')
          .data('content')
          .sides({ [this.side]: 1 })
          .create()
        const doc = await builders
          .metafile()
          .moveFrom(old)
          .path('MOVED')
          .sides({ [this.side]: 2 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['moveFrom', '_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a trashed record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metafile()
          .path('FILE')
          .trashed()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metafile(was)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was trashed
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a record marked for deletion is found in Pouch', () => {
      it('keeps the deletion marker and updates sides info', async function() {
        const was = await builders
          .metafile()
          .path('FILE')
          .deleted()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metafile(was)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was marked for deletion
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('deleteFolderAsync', function() {
    context('when a record is found in Pouch', () => {
      it('deletes a folder', async function() {
        const doc = await builders
          .metadir()
          .path('FOLDER')
          .sides({ [this.side]: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('removes nested content', async function() {
        const doc = await builders
          .metadir()
          .path('FOLDER')
          .sides({ [this.side]: 1 })
          .create()
        const subdir = await builders
          .metafile()
          .path('FOLDER/DIR')
          .sides({ [this.side]: 1 })
          .create()
        const subsubdir = await builders
          .metafile()
          .path('FOLDER/DIR/DIR')
          .sides({ [this.side]: 1 })
          .create()
        const subsubsubfile = await builders
          .metafile()
          .path('FOLDER/DIR/DIR/FILE')
          .sides({ [this.side]: 1 })
          .data('content')
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(subsubsubfile.sides, this.side, 1),
                deleted: true
              },
              _.omit(subsubsubfile, ['_id', '_rev'])
            ),
            _.defaults(
              {
                sides: increasedSides(subsubdir.sides, this.side, 1),
                deleted: true
              },
              _.omit(subsubdir, ['_id', '_rev'])
            ),
            _.defaults(
              {
                sides: increasedSides(subdir.sides, this.side, 1),
                deleted: true
              },
              _.omit(subdir, ['_id', '_rev'])
            ),
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('removes move hints', async function() {
        // TODO: make sure we remove the move hints on children. This will be part
        // of a larger refactoring to make sure folders are trashed with their
        // hierarchy.
        const old = await builders
          .metadir()
          .path('FOLDER')
          .moveTo('MOVED')
          .sides({ [this.side]: 1 })
          .create()
        const doc = await builders
          .metadir()
          .moveFrom(old)
          .path('MOVED')
          .sides({ [this.side]: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['moveFrom', '_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a trashed record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metadir()
          .path('FOLDER')
          .trashed()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was trashed
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a record marked for deletion is found in Pouch', () => {
      it('keeps the deletion marker and updates sides info', async function() {
        const was = await builders
          .metadir()
          .path('FOLDER')
          .deleted()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was marked for deletion
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('trashFileAsync', () => {
    context('when record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metafile()
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a trashed record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metafile()
          .trashed()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was trashed
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a record marked for deletion is found in Pouch', () => {
      context('and the record was modified on the other side', () => {
        it('completely erases the document from PouchDB', async function() {
          const was = await builders
            .metafile()
            .deleted()
            .changedSide(otherSide(this.side))
            .create()
          const doc = builders
            .metafile(was)
            .trashed()
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFileAsync(
              this.side,
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              {
                // _id and _rev are removed from sideEffects
                _deleted: true
              }
            ],
            resolvedConflicts: []
          })
        })
      })

      context('and the record was modified on the same side', () => {
        it('keeps the deletion marker and updates sides info', async function() {
          const was = await builders
            .metafile()
            .deleted()
            .changedSide(this.side)
            .create()
          const doc = builders
            .metafile(was)
            .trashed()
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFileAsync(
              this.side,
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaults(
                {
                  sides: increasedSides(was.sides, this.side, 1),
                  [this.side]: doc[this.side],
                  deleted: true
                },
                _.omit(was, ['_id', '_rev'])
              )
            ],
            resolvedConflicts: []
          })
        })
      })
    })

    context('when no records are found in Pouch', () => {
      it('does nothing', async function() {
        const was = builders.metafile().build()
        const doc = builders
          .metafile(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when docType of found record does not match', () => {
      it('does nothing', async function() {
        const was = await builders.metafile().create()
        const doc = builders
          .metadir()
          .path(was.path)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when found record was not synced', () => {
      it('marks it for deletion and upadtes sides info', async function() {
        const was = await builders
          .metafile()
          .sides({ [this.side]: 1 })
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('trashFolderAsync', () => {
    context('when record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metadir()
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a trashed record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metadir()
          .trashed()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was trashed
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a record marked for deletion is found in Pouch', () => {
      context('and the record was modified on the other side', () => {
        it('completely erases the record from PouchDB', async function() {
          const was = await builders
            .metadir()
            .deleted()
            .changedSide(otherSide(this.side))
            .create()
          const doc = builders
            .metadir(was)
            .trashed()
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFolderAsync(
              this.side,
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              {
                // _id and _rev are removed from sideEffects
                _deleted: true
              }
            ],
            resolvedConflicts: []
          })
        })
      })

      context('and the record was modified on the same side', () => {
        it('keeps the deletion marker and updates sides info', async function() {
          const was = await builders
            .metadir()
            .deleted()
            .changedSide(this.side)
            .create()
          const doc = builders
            .metadir(was)
            .trashed()
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFolderAsync(
              this.side,
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaults(
                {
                  sides: increasedSides(was.sides, this.side, 1),
                  [this.side]: doc[this.side],
                  deleted: true
                },
                _.omit(was, ['_id', '_rev'])
              )
            ],
            resolvedConflicts: []
          })
        })
      })
    })

    context('when no records are found in Pouch', () => {
      it('does nothing', async function() {
        const was = builders.metadir().build()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when docType of found record does not match', () => {
      it('does nothing', async function() {
        const was = await builders.metadir().create()
        const doc = builders
          .metafile()
          .path(was.path)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when found record was not synced', () => {
      it('marks it for deletion and upadtes sides info', async function() {
        const was = await builders
          .metadir()
          .sides({ [this.side]: 1 })
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('migrateFileid(existing, fileid)', () => {
    const fileid = '0x0000000000000001'
    let existing, updatedDoc

    context('when existing doc is not synced but missing a fileid', () => {
      beforeEach(async function() {
        existing = await builders
          .metadata()
          .ino(1)
          .noFileid()
          .sides({ local: 1 })
          .noRemote()
          .create()
      })

      it('does not raise Invariant errors', async function() {
        should(() => {
          this.merge.migrateFileid(_.cloneDeep(existing), fileid)
        }).not.throw()
      })

      it('updates doc with the fileid', async function() {
        await this.merge.migrateFileid(_.cloneDeep(existing), fileid)

        updatedDoc = await this.pouch.bySyncedPath(existing.path)

        should(updatedDoc).have.property('fileid', fileid)
      })
    })

    context(
      'when existing doc is already up-to-date but missing a fileid',
      () => {
        beforeEach(async function() {
          existing = await builders
            .metadata()
            .ino(1)
            .noFileid()
            .upToDate()
            .create()

          await this.merge.migrateFileid(_.cloneDeep(existing), fileid)

          updatedDoc = await this.pouch.bySyncedPath(existing.path)
        })

        it('updates doc with the fileid', async () => {
          should(updatedDoc).have.property('fileid', fileid)
        })

        it('does not make the doc out-of-date in order to prevent useless sync', async function() {
          should.not.exist(metadata.outOfDateSide(updatedDoc))
        })
      }
    )

    context('when existing doc is being synced and missing a fileid', () => {
      beforeEach(async function() {
        existing = await builders
          .metadata()
          .upToDate()
          .changedSide(this.side)
          .ino(1)
          .noFileid()
          .create()
        await this.merge.migrateFileid(_.cloneDeep(existing), fileid)

        updatedDoc = await this.pouch.bySyncedPath(existing.path)
      })

      it('updates doc with the fileid', async () => {
        should(updatedDoc).have.property('fileid', fileid)
      })

      it('keeps the same out-of-date side in order not to prevent sync', async function() {
        should(metadata.outOfDateSide(updatedDoc)).equal(otherSide(this.side))
      })
    })
  })
})
