/* @flow */
/* eslint-env mocha */

const _ = require('lodash')
const sinon = require('sinon')
const should = require('should')
const path = require('path')

const { Merge } = require('../../core/merge')
const metadata = require('../../core/metadata')
const { otherSide } = require('../../core/side')
const pathUtils = require('../../core/utils/path')

const configHelpers = require('../support/helpers/config')
const cozyHelpers = require('../support/helpers/cozy')
const { onPlatform, onPlatforms } = require('../support/helpers/platform')
const pouchHelpers = require('../support/helpers/pouch')
const Builders = require('../support/builders')
const stubSide = require('../support/doubles/side')

const win32 = (
  win32Data /*: Object */,
  otherwise /*: ?Object */ = undefined
) /*: ?Object */ => (process.platform === 'win32' ? win32Data : otherwise)

/* Resolves with an object describing the side-effects of a Merge call.
 *
 * The returned object has the following properties:
 *
 * - `savedDocs`: Which docs were changed in `Pouch`
 * - `resolvedConflicts`: Which conflits were resolved on which side
 */
async function mergeSideEffects(
  { merge, pouch } /*: * */,
  mergeCall /*: () => Promise<*> */
) {
  const { last_seq: lastSeq } = await pouch.db.changes({ since: 'now' })

  if (merge.resolveConflictAsync.restore) merge.resolveConflictAsync.restore()
  const { resolveConflictAsync } = merge
  sinon.stub(merge, 'resolveConflictAsync').callsFake((...args) => {
    const clones = args.map(arg => _.cloneDeep(arg))
    return resolveConflictAsync(...clones)
  })

  await mergeCall()

  const opts = { since: lastSeq, include_docs: true }
  const { results } = await pouch.db.changes(opts)
  const savedDocs = results.map(({ doc }) => {
    if (metadata.extractRevNumber(doc) === 1) {
      // Don't include _id and _rev of new records in assertions: they are
      // randomly generated by Pouch, which makes them hard to compare.
      delete doc._id
      delete doc._rev
    } else {
      // Only remove _rev on modified records since we should be able to compare
      // the resulting _id.
      delete doc._rev
    }

    if (process.platform !== 'win32') {
      delete doc.fileid
    }

    return doc
  })

  return {
    savedDocs,
    resolvedConflicts: merge.resolveConflictAsync.args.map(([side, doc]) => [
      side,
      // Include only properties that are relevant in conflict resolution:
      _.pick(doc, [
        // The path is necessary to:
        // - generate the new file/dir name including the conflict suffix.
        // - rename the conflicting file/dir on the local side.
        'path',
        // The remote._id is necessary to rename the conflicting file/dir on
        // the remote side. Actually the remote._rev is not used although
        // we're currently including it in the test-asserted data as part of
        // the remote property.
        'remote'
      ])
      // Don't include the existing version: it is only useful for
      // logging / debugging and has no impact on conflict resolution.
    ])
  }
}

function increasedSides(sides, sideName, count) {
  const increasedSide = sides[sideName] + count
  return {
    ...sides,
    target: increasedSide,
    [sideName]: increasedSide
  }
}

describe('Merge', function() {
  let builders

  before('instanciate config', configHelpers.createConfig)
  beforeEach('instanciate pouch', pouchHelpers.createDatabase)
  beforeEach('instanciate merge', function() {
    this.side = 'local'
    this.merge = new Merge(this.pouch)
    this.merge.local = stubSide('local')
    this.merge.local.resolveConflict = sinon.stub().callsFake(doc => {
      const conflict = metadata.createConflictingDoc(doc)
      // XXX: We cannot stub `fs.rename` as it's directly imported by `Local`
      // but we care about the `local` attribute being updated so we
      // explicitely call `metadata.updateLocal()`.
      metadata.updateLocal(conflict)
      return conflict
    })
    this.merge.remote = stubSide('remote')
    this.merge.remote.resolveConflict = sinon.stub().callsFake(doc => {
      const conflict = metadata.createConflictingDoc(doc)
      // XXX: It would be cumbersome to stub the content of this method but we
      // care about the `remote` attribute being updated so we explicitely
      // call `metadata.updateRemote()`.
      metadata.updateRemote(conflict, {
        path: pathUtils.localToRemote(conflict.path)
      })
      return conflict
    })
    builders = new Builders({ cozy: cozyHelpers.cozy, pouch: this.pouch })
  })
  afterEach('clean pouch', pouchHelpers.cleanDatabase)
  afterEach('clean remote', cozyHelpers.deleteAll)
  after('clean config directory', configHelpers.cleanConfig)

  describe('addFile', function() {
    it('saves the new file', async function() {
      const doc = builders
        .metafile()
        .path('new-file')
        .data('content')
        .tags('courge', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    context('remote', function() {
      context(
        'when an unsynced local file record with the same path but different content exists',
        () => {
          const filepath = 'BUZZ.JPG'

          beforeEach('create a file', async function() {
            await builders
              .metafile()
              .path(filepath)
              .data('local content')
              .sides({ local: 1 })
              .create()
          })

          it('creates a remote conflict', async function() {
            const newRemoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('remote content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            const doc = builders
              .metafile()
              .fromRemote(newRemoteFile)
              .unmerged('remote')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('remote', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: [
                ['remote', { path: filepath, remote: doc.remote }]
              ]
            })
          })
        }
      )

      context(
        'when an unsynced local file record with the same path and content exists',
        () => {
          const filepath = 'BUZZ.JPG'

          let file
          beforeEach('create a file', async function() {
            file = await builders
              .metafile()
              .path(filepath)
              .data('same content')
              .sides({ local: 1 })
              .create()
          })

          it('updates the record with the remote metadata', async function() {
            const newRemoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('same content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            const doc = builders
              .metafile()
              .fromRemote(newRemoteFile)
              .unmerged('remote')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('remote', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    mime: doc.mime,
                    class: doc.class,
                    tags: ['foo'],
                    executable: doc.executable,
                    updated_at: doc.updated_at,
                    sides: {
                      local: file.sides.local,
                      remote: file.sides.target + 1,
                      target: file.sides.target + 1
                    },
                    remote: doc.remote,
                    cozyMetadata: doc.cozyMetadata,
                    // FIXME: $FlowFixMe not part of Metadata but still saved in PouchDB
                    created_at: doc.created_at,
                    // FIXME: $FlowFixMe not part of Metadata but still saved in PouchDB
                    dir_id: doc.dir_id,
                    // FIXME: $FlowFixMe not part of Metadata but still saved in PouchDB
                    name: doc.name
                  },
                  _.omit(file, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when a record with an unsynced local deletion and different content exists',
        () => {
          const filepath = 'BUZZ.JPG'

          let remoteFile, deleted
          beforeEach('create a file', async function() {
            remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('initial content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            const synced = await builders
              .metafile()
              .fromRemote(remoteFile)
              .upToDate()
              .create()
            deleted = await builders
              .metafile(synced)
              .deleted()
              .changedSide('local')
              .create()
          })

          it('replaces the existing record with a new remote file record', async function() {
            const newRemoteFile = await builders
              .remoteFile(remoteFile)
              .data('updated content')
              .build()
            const doc = builders
              .metafile()
              .fromRemote(newRemoteFile)
              .unmerged('remote')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('remote', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    _id: deleted._id,
                    sides: { target: 1, remote: 1 }
                  },
                  _.omit(doc, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when an up-to-date file record with the same path exists',
        () => {
          const filepath = 'BUZZ.JPG'

          let file
          beforeEach('create a file', async function() {
            file = await builders
              .metafile()
              .path(filepath)
              .data('initial content')
              .ino(123)
              .upToDate()
              .create()
          })

          it('updates the existing record', async function() {
            const newRemoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('new content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            const doc = builders
              .metafile()
              .fromRemote(newRemoteFile)
              .unmerged('remote')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('remote', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    sides: increasedSides(file.sides, 'remote', 1),
                    local: file.local
                  },
                  doc,
                  _.omit(file, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )
    })

    context('local', function() {
      const filepath = 'BUZZ.JPG'

      context(
        'when an unsynced remote file record with the same path but different content exists',
        () => {
          let file
          beforeEach('create a file', async function() {
            const remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('remote content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            file = await builders
              .metafile()
              .fromRemote(remoteFile)
              .sides({ remote: 1 })
              .create()
          })

          it('creates a local conflict', async function() {
            const doc = await builders
              .metafile()
              .path(filepath)
              .data('local content')
              .ino(123)
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: [
                ['local', { path: filepath, remote: file.remote }]
              ]
            })
          })
        }
      )

      context(
        'when an unsynced remote file record with the same path and content exists',
        () => {
          let file
          beforeEach('create a file', async function() {
            const remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('same content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            file = await builders
              .metafile()
              .fromRemote(remoteFile)
              .sides({ remote: 1 })
              .create()
          })

          it('updates the record with the local metadata', async function() {
            const doc = await builders
              .metafile()
              .path(filepath)
              .data('same content')
              .ino(123)
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  win32({ fileid: doc.fileid }),
                  {
                    ino: doc.ino,
                    executable: win32(file.executable, doc.executable),
                    mime: doc.mime,
                    class: doc.class,
                    updated_at: doc.updated_at,
                    sides: {
                      remote: file.sides.remote,
                      local: file.sides.target + 1,
                      target: file.sides.target + 1
                    },
                    local: doc.local
                  },
                  _.omit(file, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when a deleted remote file record with the same path and content exists',
        () => {
          let synced
          beforeEach('create a file', async function() {
            const remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('same content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            synced = await builders
              .metafile()
              .fromRemote(remoteFile)
              .upToDate()
              .create()
            await builders
              .metafile(synced)
              .deleted()
              .changedSide('remote')
              .create()
          })

          it('does not overwrite the existing record', async function() {
            const doc = await builders
              .metafile(synced)
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when a record with an unsynced remote deletion and different content exists',
        () => {
          let synced, deleted
          beforeEach('create a file', async function() {
            const remoteFile = await builders
              .remoteFile()
              .inRootDir()
              .name(filepath)
              .data('remote content')
              .tags('foo')
              .contentType('image/jpeg')
              .build()
            synced = await builders
              .metafile()
              .fromRemote(remoteFile)
              .upToDate()
              .create()
            deleted = await builders
              .metafile(synced)
              .deleted()
              .changedSide('remote')
              .create()
          })

          it('updates the existing record', async function() {
            const doc = await builders
              .metafile(synced)
              .data('local content')
              .updatedAt(new Date())
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    _id: deleted._id,
                    // Local side is increased by 2 to overcome the unsynced
                    // remote deletion.
                    sides: increasedSides(deleted.sides, 'local', 2),
                    remote: deleted.remote
                  },
                  _.omit(doc, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )

      context(
        'when an up-to-date file record with the same path exists',
        () => {
          let file
          beforeEach('create a file', async function() {
            file = await builders
              .metafile()
              .path(filepath)
              .data('initial content')
              .ino(123)
              .upToDate()
              .create()
          })

          it('updates the existing record', async function() {
            const doc = builders
              .metafile()
              .path(filepath)
              .data('new content')
              .ino(456)
              .updatedAt(new Date())
              .unmerged('local')
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.addFileAsync('local', _.cloneDeep(doc))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  win32({ fileid: doc.fileid }),
                  {
                    ino: doc.ino,
                    md5sum: doc.md5sum,
                    size: doc.size,
                    updated_at: doc.updated_at,
                    sides: increasedSides(file.sides, 'local', 1),
                    local: doc.local
                  },
                  _.omit(file, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )
    })

    context('when the path was used in the past', function() {
      const path = 'file-created-deleted-and-then-recreated'

      beforeEach(async function() {
        const was = await builders
          .metafile()
          .path(path)
          .data('content')
          .upToDate()
          .create()
        await this.pouch.remove(was)
      })

      it('saves the new file with the correct side number', async function() {
        const doc = builders
          .metafile()
          .path(path)
          .data('file content')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { target: 1, [this.side]: 1 }
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('resolves an identity conflict with an existing file', async function() {
        await builders
          .metafile()
          .path('bar')
          .upToDate()
          .create()
        const doc = builders
          .metafile()
          .path('BAR')
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('remote', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [['remote', _.pick(doc, ['path', 'remote'])]]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not have identity conflicts', async function() {
        await builders
          .metafile()
          .path('bar')
          .upToDate()
          .create()
        const doc = builders
          .metafile()
          .path('BAR')
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('remote', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { target: 1, remote: 1 }
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('resolves a conflict with an existing dir', async function() {
      const existingLocalDir = await builders
        .metadir()
        .sides({ local: 1 })
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(existingLocalDir.path)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(newRemoteFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteFile, ['path', 'remote'])]
        ]
      })
    })

    it('does nothing for an already merged file (aka idempotence)', async function() {
      const mergedFile = await builders
        .metafile()
        .sides({ remote: 1 })
        .create()
      const sameFile = builders
        .metafile(mergedFile)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    context('when content is the same as an existing file', () => {
      it('updates the PouchDB record without marking changes from a local update', async function() {
        const mergedFile = await builders
          .metafile()
          .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
          .upToDate()
          .create()
        const sameFile = builders
          .metafile(mergedFile)
          .updatedAt(new Date())
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(sameFile))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                local: sameFile.local,
                updated_at: sameFile.updated_at
              },
              _.omit(mergedFile, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('sets the local metadata when it is missing', async function() {
        const mergedFile = await builders
          .metafile()
          .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
          .upToDate()
          .create()

        // Remove local attribute for the test
        delete mergedFile.local
        const { rev } = await this.pouch.db.put(mergedFile)
        mergedFile._rev = rev

        const sameFile = builders
          .metafile(mergedFile)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(sameFile))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                local: sameFile.local
              },
              _.omit(mergedFile, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('keeps an existing local metadata when it is not present in the new doc', async function() {
      const oldRemoteFile = await builders
        .remoteFile()
        .updatedAt(2020, 5, 19, 11, 9, 0)
        .build()
      const mergedFile = await builders
        .metafile()
        .fromRemote(oldRemoteFile)
        .upToDate()
        .create()
      const newRemoteFile = await builders
        .remoteFile(oldRemoteFile)
        .tags('qux')
        .build()
      const sameFile = builders
        .metafile()
        .fromRemote(newRemoteFile)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.addFileAsync('remote', _.cloneDeep(sameFile))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              _id: mergedFile._id,
              sides: increasedSides(mergedFile.sides, 'remote', 1),
              local: mergedFile.local
            },
            _.omit(sameFile, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context('on initial scan', function() {
      it('saves an offline update after an unsynced local addition', async function() {
        const initialFile = await builders
          .metafile()
          .sides({ local: 1 })
          .ino(123)
          .noRemote()
          .data('initial content')
          .create()
        const offlineUpdate = await builders
          .metafile(initialFile)
          .data('offline update')
          .newerThan(initialFile)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(offlineUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                _id: initialFile._id,
                sides: increasedSides(initialFile.sides, 'local', 1)
              },
              _.omit(offlineUpdate, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('saves an offline update after an unsynced local update', async function() {
        const initial = await builders
          .metafile()
          .path('yafile')
          .ino(37)
          .data('initial content')
          .upToDate()
          .create()
        const firstUpdate = await builders
          .metafile(initial)
          .changedSide('local')
          .data('first update')
          .create()
        const secondUpdate = builders
          .metafile(firstUpdate)
          .data('second update')
          .newerThan(firstUpdate)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(secondUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                _id: initial._id,
                sides: increasedSides(firstUpdate.sides, 'local', 1),
                remote: initial.remote
              },
              _.omit(secondUpdate, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does nothing for an locally untouched file after an unsynced remote update', async function() {
        const synced = await builders
          .metafile()
          .data('previous content')
          .upToDate()
          .create()
        await builders
          .metafile(synced)
          .data('remote update')
          .changedSide('remote')
          .create()
        const sameAsSynced = builders
          .metafile(synced)
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(sameAsSynced))
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })

      // XXX: This sides are increased on the remote update to make sure it will
      // get synced.
      it('creates a conflict for an oflline local update after an unsynced remote update', async function() {
        const synced = await builders
          .metafile()
          .data('initial content')
          .upToDate()
          .create()
        const remoteUpdate = await builders
          .metafile(synced)
          .data('remote update')
          .updatedAt(new Date())
          .changedSide('remote')
          .create()
        const localUpdate = builders
          .metafile(synced)
          .data('local update')
          .updatedAt(new Date())
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.addFileAsync('local', _.cloneDeep(localUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: {
                  remote: remoteUpdate.sides.remote + 1,
                  target: remoteUpdate.sides.target + 1
                }
              },
              _.omit(remoteUpdate, ['_rev', 'local'])
            )
          ],
          resolvedConflicts: [
            ['local', { path: localUpdate.path, remote: remoteUpdate.remote }]
          ]
        })
      })
    })
  })

  describe('updateFile', () => {
    let file

    beforeEach('create synced file', async function() {
      file = await builders
        .metafile()
        .path('FIZZBUZZ.JPG')
        .ino(3456)
        .data('image')
        .type('image/jpeg')
        .tags('foo')
        .upToDate()
        .updatedAt(new Date(2020, 5, 17, 15, 33, 30, 0)) // Necessary for date change tests
        .create()
    })

    it('creates the file if it does not exist', async function() {
      const doc = builders
        .metafile()
        .path('NEW-FILE')
        .data('content')
        .tags('courge', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when content is the same', () => {
      it('updates the PouchDB record without marking changes from a remote update', async function() {
        const doc = builders
          .metafile(file)
          .tags('bar', 'baz')
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          // Tags are only coming from the Cozy so we should not expect any tags
          // update coming from the local side.
          this.merge.updateFileAsync('remote', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(file.sides, 'remote', 1),
                remote: doc.remote,
                tags: ['bar', 'baz']
              },
              _.omit(file, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      // XXX: Here we don't increase the sides as we don't want to propagate a
      // simple change of modification date.
      it('updates the PouchDB record without marking changes from a local update', async function() {
        const doc = builders
          .metafile(file)
          .updatedAt(new Date())
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.updateFileAsync('local', _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                local: { updated_at: doc.local.updated_at },
                updated_at: doc.updated_at
              },
              _.omit(file, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('does nothing when the modification date is the same', async function() {
      const doc = builders
        .metafile(file)
        .md5sum('xxx')
        .size(file.size + 1)
        .ino(file.ino + 1)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('sets the local metadata when it is missing', async function() {
      // Remove local attribute for the test
      delete file.local
      const { rev } = await this.pouch.db.put(file)
      file._rev = rev

      const doc = builders
        .metafile(file)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              local: doc.local
            },
            _.omit(file, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps an existing local metadata for a remote update', async function() {
      const doc = builders
        .metafile(file)
        .data('updated content')
        .updatedAt(new Date())
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('remote', _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              _id: file._id,
              sides: increasedSides(file.sides, 'remote', 1),
              local: file.local
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps an existing remote metadata for a local update', async function() {
      const doc = builders
        .metafile(file)
        .data('new content')
        .updatedAt(new Date())
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              _id: file._id,
              sides: increasedSides(file.sides, 'local', 1),
              remote: file.remote
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps the overwrite attribute if it exists', async function() {
      // Overwrite file with a move
      const src = await builders
        .metafile()
        .changedSide(this.side)
        .create()
      const dst = await builders
        .metafile()
        .moveFrom(src)
        .path(file.path)
        .overwrite(file)
        .updatedAt(new Date(new Date().getTime() - 1000))
        .changedSide(this.side)
        .create()

      const doc = builders
        .metafile(dst)
        .data('final content')
        .updatedAt(new Date())
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(dst.sides, this.side, 1),
              moveFrom: src,
              overwrite: file,
              [otherSide(this.side)]: dst[otherSide(this.side)],
              _id: src._id // XXX: should be the same as `dst._id`
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps the overwrite attribute if it exists', async function() {
      const firstUpdateDate = new Date()
      const firstUpdate = await builders
        .metafile(file)
        .overwrite(file)
        .data('new content')
        .tags('qux', 'quux')
        .updatedAt(firstUpdateDate)
        .changedSide(this.side)
        .noRecord() // XXX: Prevent Pouch conflict from reusing `file`'s _id
        .create()
      const doc = builders
        .metafile(firstUpdate)
        .data('final content')
        .tags('qux', 'quux')
        .updatedAt(new Date(firstUpdateDate.getTime() + 1))
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              _id: firstUpdate._id,
              sides: increasedSides(file.sides, this.side, 2),
              overwrite: file,
              [otherSide(this.side)]: firstUpdate[otherSide(this.side)]
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('rejects an unresolvable conflict with an existing directory', async function() {
      // FIXME: Why don't we resolve the conflict like everywhere else?
      const existingLocalDir = await builders
        .metadir()
        .sides({ local: 1 })
        .create()
      const newRemoteFile = builders
        .metafile()
        .path(existingLocalDir.path)
        .unmerged('remote')
        .build()

      await should(
        this.merge.updateFileAsync('local', _.cloneDeep(newRemoteFile))
      ).be.rejectedWith(/conflict/)
    })

    it('resolves a conflict between a new remote update and a previous local version', async function() {
      const initial = await builders
        .metafile()
        .sides({ local: 1 })
        .ino(456)
        .data('initial content')
        .create()
      const synced = await builders
        .metafile(initial)
        .upToDate()
        .create()
      const mergedLocalUpdate = await builders
        .metafile(synced)
        .changedSide('local')
        .data('local update')
        .create()
      const newRemoteUpdate = builders
        .metafile(synced)
        .data('remote update')
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('remote', _.cloneDeep(newRemoteUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: {
                target: mergedLocalUpdate.sides.target + 1,
                local: mergedLocalUpdate.sides.local + 1
              }
            },
            // We're dissociating the local doc from the remote doc
            _.omit(mergedLocalUpdate, ['_rev', 'remote'])
          )
        ],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteUpdate, ['path', 'remote'])]
        ]
      })
    })

    it('does not overwrite an unsynced remote update with a locally unchanged file', async function() {
      const synced = await builders
        .metafile()
        .data('initial content')
        .upToDate()
        .create()
      await builders
        .metafile(synced)
        .overwrite(synced)
        .data('remote update')
        .changedSide('remote')
        .noRecord() // XXX: Prevent Pouch conflict from reusing `synced`'s _id
        .create()
      const unchangedLocal = builders
        .metafile(synced)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(unchangedLocal))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('does not overwrite an unsynced remote update with a locally updated file and creates a local conflict', async function() {
      const synced = await builders
        .metafile()
        .data('initial content')
        .upToDate()
        .create()
      const remoteUpdate = await builders
        .metafile(synced)
        .data('remote update')
        .updatedAt(new Date())
        .changedSide('remote')
        .create()
      const newLocalUpdate = builders
        .metafile(synced)
        .data('local update')
        .updatedAt(new Date())
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.updateFileAsync('local', _.cloneDeep(newLocalUpdate))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: {
                remote: remoteUpdate.sides.remote + 1,
                target: remoteUpdate.sides.remote + 1
              }
            },
            _.omit(remoteUpdate, ['_rev', 'local'])
          )
        ],
        resolvedConflicts: [
          ['local', { path: newLocalUpdate.path, remote: remoteUpdate.remote }]
        ]
      })
    })

    context('when existing file is the same and up-to-date', () => {
      it('updates the PouchDB record without marking changes', async function() {
        const initial = await builders
          .metafile()
          .data('initial content')
          .upToDate()
          .create()
        const updated = await builders
          .metafile(initial)
          .data('updated content')
          .updatedAt(new Date(2020, 5, 12, 10, 15, 0))
          .upToDate()
          .create()
        const sameUpdate = builders
          .metafile(updated)
          .updatedAt(new Date())
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.updateFileAsync(this.side, _.cloneDeep(sameUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                [this.side]: sameUpdate[this.side],
                updated_at: sameUpdate.updated_at // XXX: only attribute changed
              },
              _.omit(updated, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when the file is a Cozy Note export', () => {
      it('does not create a conflict', async function() {
        const remoteNote = await builders
          .remoteNote()
          .name('my-note.cozy-note')
          .data('initial content')
          .create()
        const synced = await builders
          .metafile()
          .fromRemote(remoteNote)
          .upToDate()
          .create()
        const localUpdate = builders
          .metafile(synced)
          .data('local update')
          .updatedAt(new Date())
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.updateFileAsync('local', _.cloneDeep(localUpdate))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                _id: synced._id,
                sides: increasedSides(synced.sides, 'local', 1),
                remote: synced.remote
              },
              localUpdate
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('putFolder', () => {
    it('saves the new folder', async function() {
      const doc = builders
        .metadir()
        .path('NEW-FOLDER')
        .tags('courge', 'quux')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: { target: 1, [this.side]: 1 }
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    it('saves a new version of an existing folder', async function() {
      const old = await builders
        .metadir()
        .path('existing-folder')
        .upToDate()
        .create()
      const doc = builders
        .metadir(old)
        .tags('changed-tag')
        .ino(123)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              _id: old._id,
              sides: increasedSides(old.sides, this.side, 1),
              [otherSide(this.side)]: old[otherSide(this.side)]
            },
            _.omit(doc, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the path was used in the past', function() {
      const path = 'folder-created-deleted-and-then-recreated'

      beforeEach(async function() {
        const was = await builders
          .metadir()
          .path(path)
          .sides({ [this.side]: 1 })
          .create()
        await this.pouch.remove(was)
      })

      it('saves the new folder with the correct side number', async function() {
        const doc = builders
          .metadir()
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: { target: 1, [this.side]: 1 }
              },
              _.omit(doc, ['_id', '_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('does nothing when existing folder is up to date', async function() {
      const old = await builders
        .metadir()
        .path('up-to-date-folder')
        .upToDate()
        .create()
      const doc = builders
        .metadir(old)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync(this.side, _.cloneDeep(doc))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    // XXX: it would be preferable to store the new local date but we need to
    // avoid merging folder changes triggered while adding content and merged
    // after we've synchronized a local renaming (i.e. the change which was
    // waiting to be dispatched is now obsolete and merging it would cause
    // issues).
    // Until we find a way to mark specific events as obsolete, our only
    // recourse is to discard these modification date changes.
    it('does nothing when only the modification date has changed', async function() {
      const mergedFolder = await builders
        .metadir()
        .upToDate()
        .create()
      const sameFolder = builders
        .metadir(mergedFolder)
        .updatedAt(new Date())
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('local', _.cloneDeep(sameFolder))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })

    it('resolves a conflict with an existing file', async function() {
      const existingLocalFile = await builders
        .metafile()
        .sides({ local: 1 })
        .create()
      const newRemoteDir = builders
        .metadir()
        .path(existingLocalFile.path)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('remote', _.cloneDeep(newRemoteDir))
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: [
          ['remote', _.pick(newRemoteDir, ['path', 'remote'])]
        ]
      })
    })

    it('sets the local metadata when it is missing', async function() {
      const mergedFolder = await builders
        .metadir()
        .updatedAt(new Date(2020, 5, 19, 11, 9, 0))
        .upToDate()
        .create()

      // Remove local attribute for the test
      delete mergedFolder.local
      const { rev } = await this.pouch.db.put(mergedFolder)
      mergedFolder._rev = rev

      const sameFolder = builders
        .metadir(mergedFolder)
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('local', _.cloneDeep(sameFolder))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              _id: mergedFolder._id,
              local: sameFolder.local
            },
            _.omit(mergedFolder, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('keeps existing local metadata when it is not present in the new doc', async function() {
      const oldRemoteDir = await builders
        .remoteDir()
        .updatedAt(2020, 5, 19, 11, 9, 0)
        .build()
      const mergedFolder = await builders
        .metadir()
        .fromRemote(oldRemoteDir)
        .upToDate()
        .create()
      const newRemoteDir = await builders
        .remoteDir(oldRemoteDir)
        .tags('qux')
        .build()

      const updatedFolder = builders
        .metadir()
        .fromRemote(newRemoteDir)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.putFolderAsync('remote', _.cloneDeep(updatedFolder))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaultsDeep(
            {
              _id: mergedFolder._id,
              sides: increasedSides(mergedFolder.sides, 'remote', 1),
              local: mergedFolder.local
            },
            _.omit(updatedFolder, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context(
      'when doc can have an identity conflict with an existing dir',
      () => {
        let Alfred

        beforeEach(async function() {
          await builders
            .metadir()
            .path('alfred')
            .sides({ [otherSide(this.side)]: 1 })
            .create()
          Alfred = await builders
            .metadir()
            .path('Alfred')
            .unmerged(this.side)
            .build()
        })

        onPlatforms(['win32', 'darwin'], () => {
          it('resolves the conflict', async function() {
            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.putFolderAsync(this.side, _.cloneDeep(Alfred))
            )

            should(sideEffects).deepEqual({
              savedDocs: [],
              resolvedConflicts: [
                [this.side, _.pick(Alfred, ['path', 'remote'])]
              ]
            })
          })
        })

        onPlatform('linux', () => {
          it('saves the doc as a new doc', async function() {
            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.putFolderAsync(this.side, _.cloneDeep(Alfred))
            )

            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaultsDeep(
                  {
                    sides: { target: 1, [this.side]: 1 }
                  },
                  Alfred
                )
              ],
              resolvedConflicts: []
            })
          })
        })
      }
    )
  })

  describe('moveFileAsync', function() {
    beforeEach('create parent folder', async function() {
      await builders
        .metadir()
        .path('FOO')
        .upToDate()
        .create()
    })

    context('local', () => {
      it('saves the moved file', async function() {
        const was = await builders
          .metafile()
          .path('FOO/OLD')
          .ino(1)
          .upToDate()
          .data('content')
          .tags('courge', 'quux')
          .create()
        const doc = builders
          .metafile(was)
          .path('FOO/NEW')
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              win32({ fileid: was.fileid }),
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: was,
                [otherSide(this.side)]: was[otherSide(this.side)],
                ino: was.ino,
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('remote', () => {
      it('saves the moved file', async function() {
        const oldRemoteFile = await builders
          .remoteFile()
          .inRootDir()
          .name('OLD')
          .data('content')
          .shortRev(1)
          .build()
        const was = await builders
          .metafile()
          .fromRemote(oldRemoteFile)
          .ino(1)
          .upToDate()
          .create()
        const newRemoteFile = await builders
          .remoteFile(oldRemoteFile)
          .name('NEW')
          .shortRev(2)
          .build()
        const doc = builders
          .metafile()
          .fromRemote(newRemoteFile)
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              win32({ fileid: was.fileid }),
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: was,
                [this.side]: was[this.side],
                ino: was.ino,
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('adds missing fields', async function() {
      const was = await builders
        .metafile()
        .path('FOO/OLD-MISSING-FIELDS.JPG')
        .ino(3854)
        .data('image')
        .type('image/jpeg')
        .tags('courge', 'quux')
        .upToDate()
        .create()
      const doc = builders
        .metafile(was)
        .path('FOO/NEW-MISSING-FIELDS.JPG')
        .noTags()
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync(this.side, _.cloneDeep(doc), _.cloneDeep(was))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: was,
              [otherSide(this.side)]: was[otherSide(this.side)],
              tags: was.tags,
              _id: was._id
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    context('when the destination exists', () => {
      let existing

      beforeEach(async function() {
        existing = await builders
          .metafile()
          .path('DST_FILE')
          .updatedAt(new Date(2020, 5, 19, 12, 12, 0))
          .upToDate()
          .create()
      })

      it('erases the existing destination record and saves the moved file', async function() {
        const was = await builders
          .metafile()
          .path('SRC_FILE')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path(existing.path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            {
              _deleted: true,
              _id: existing._id
            },
            _.defaults(
              {
                path: doc.path,
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: was,
                overwrite: existing,
                [otherSide(this.side)]: was[otherSide(this.side)],
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })

      it('keeps the overwrite attribute if it exists', async function() {
        const overwritten = await builders
          .metafile(existing)
          .overwrite(existing)
          .changedSide(this.side)
          .data('new content')
          .tags('qux', 'quux')
          .noRecord() // XXX: Prevent Pouch conflict from reusing `existing`'s _id
          .create()
        const was = await builders
          .metafile()
          .path('SRC_FILE')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path(existing.path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            {
              _deleted: true,
              _id: overwritten._id
            },
            _.defaults(
              {
                path: doc.path,
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: was,
                overwrite: existing,
                [otherSide(this.side)]: was[otherSide(this.side)],
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })

      context('and we have unapplied modifications on the other side', () => {
        beforeEach(async function() {
          existing = await builders
            .metafile(existing)
            .data('new content')
            .changedSide('remote')
            .create()
        })

        it('resolves a conflict', async function() {
          const was = await builders
            .metafile()
            .path('SRC_FILE')
            .upToDate()
            .create()
          const doc = builders
            .metafile(was)
            .path(existing.path)
            .unmerged('local')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFileAsync(
              'local',
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const { path: dstPath } = _.find(sideEffects.savedDocs, ({ path }) =>
            path.match(/conflict/)
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaultsDeep(
                {
                  path: dstPath,
                  sides: increasedSides(was.sides, 'local', 1),
                  moveFrom: was,
                  local: { path: dstPath },
                  remote: was.remote,
                  _id: was._id
                },
                doc
              )
            ],
            resolvedConflicts: [
              ['local', { path: doc.path, remote: was.remote }]
            ]
          })
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_FILE'

      beforeEach(async function() {
        const previous = await builders
          .metafile()
          .path(path)
          .upToDate()
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the moved file with the correct side', async function() {
        const was = await builders
          .metafile()
          .path('SRC_FILE')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: was,
                [otherSide(this.side)]: was[otherSide(this.side)],
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('replaces a local move with an addition for a local-only file', async function() {
      const was = await builders
        .metafile()
        .path('FOO/OLD')
        .data('content')
        .tags('courge', 'quux')
        .sides({ local: 1 })
        .create()
      const doc = builders
        .metafile(was)
        .path('FOO/NEW')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('local', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const fileAddition = _.defaults(
        {
          sides: { target: 1, local: 1 },
          _id: was._id
        },
        doc
      )
      should(sideEffects).deepEqual({
        savedDocs: [fileAddition],
        resolvedConflicts: []
      })
    })

    it('replaces a remote move with an addition for a remote-only file', async function() {
      const oldRemoteFile = builders
        .remoteFile()
        .inRootDir()
        .name('OLD')
        .data('content')
        .build()
      const was = await builders
        .metafile()
        .fromRemote(oldRemoteFile)
        .sides({ remote: 1 })
        .create()
      const newRemoteFile = builders
        .remoteFile(oldRemoteFile)
        .name('NEW')
        .build()
      const doc = builders
        .metafile()
        .fromRemote(newRemoteFile)
        .unmerged('remote')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('remote', _.cloneDeep(doc), _.cloneDeep(was))
      )

      const fileAddition = _.defaults(
        {
          sides: { target: 1, remote: 1 },
          _id: was._id
        },
        doc
      )
      should(sideEffects).deepEqual({
        savedDocs: [fileAddition],
        resolvedConflicts: []
      })
    })

    it('does not identify the child file move following another unsynced move as an addition', async function() {
      const src = await builders
        .metadir()
        .path('SRC')
        .upToDate()
        .create()
      const file = await builders
        .metafile()
        .path('SRC/FILE')
        .upToDate()
        .create()
      const file2 = builders
        .metafile(file)
        .path('SRC/FILE2')
        .unmerged('local')
        .build()
      await this.merge.moveFileAsync(
        'local',
        _.cloneDeep(file2),
        _.cloneDeep(file)
      )

      const was = await this.pouch.bySyncedPath(file2.path)
      const dst = builders
        .metadir(src)
        .path('DST')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync('local', _.cloneDeep(dst), _.cloneDeep(src))
      )

      const fileDstPath = was.path.replace(src.path, dst.path)
      const movedFile = _.defaults(
        {
          childMove: true
        },
        was
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(src.sides, this.side, 1),
              moveFrom: src,
              remote: src.remote,
              _id: src._id
            },
            dst
          ),
          _.defaultsDeep(
            {
              path: fileDstPath,
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: movedFile,
              local: {
                path: fileDstPath
              }
            },
            _.omit(was, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    it('does not identify the local move of a file following an unsynced child move as an addition', async function() {
      const src = await builders
        .metadir()
        .path('SRC')
        .upToDate()
        .create()
      await builders
        .metafile()
        .path('SRC/FILE')
        .upToDate()
        .create()
      const dst = builders
        .metadir(src)
        .path('DST')
        .unmerged('local')
        .build()
      await this.merge.moveFolderAsync(
        'local',
        _.cloneDeep(dst),
        _.cloneDeep(src)
      )

      const was = await this.pouch.bySyncedPath(path.normalize('DST/FILE'))
      const doc = await builders
        .metafile(was)
        .path('DST/FILE2')
        .unmerged('local')
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFileAsync('local', _.cloneDeep(doc), _.cloneDeep(was))
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(was.sides, 'local', 1),
              moveFrom: was,
              remote: was.remote,
              _id: was._id
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const banana = await builders
          .metafile()
          .path('banana')
          .upToDate()
          .create()
        const BANANA = builders
          .metafile(banana)
          .path('BANANA')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(BANANA),
            _.cloneDeep(banana)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                sides: increasedSides(banana.sides, this.side, 1),
                moveFrom: banana,
                [otherSide(this.side)]: banana[otherSide(this.side)],
                _id: banana._id
              },
              BANANA
            )
          ],
          resolvedConflicts: []
        })
      })

      it('resolves an identity conflict with an existing file', async function() {
        await builders
          .metafile()
          .path('QUX')
          .upToDate()
          .create()
        const was = await builders
          .metafile()
          .path('baz')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path('qux')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: [
            [this.side, { path: doc.path, remote: was.remote }]
          ]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const banana = await builders
          .metafile()
          .path('banana')
          .upToDate()
          .create()
        const BANANA = builders
          .metafile(banana)
          .path('BANANA')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(BANANA),
            _.cloneDeep(banana)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(banana.sides, this.side, 1),
                moveFrom: banana,
                [otherSide(this.side)]: banana[otherSide(this.side)],
                _id: banana._id
              },
              BANANA
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not have identity conflicts', async function() {
        const was = await builders
          .metafile()
          .path('baz')
          .upToDate()
          .create()
        await builders
          .metafile()
          .path('QUX')
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .path('qux')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFileAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: was,
                [otherSide(this.side)]: was[otherSide(this.side)],
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('moveFolderAsync', function() {
    context('local', () => {
      it('saves the new folder and deletes the old one with hints for writers', async function() {
        const was = await builders
          .metadir()
          .path('OLD')
          .ino(666)
          .tags('courge', 'quux')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path('NEW')
          .unmerged('local')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            'local',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, 'local', 1),
                moveFrom: was,
                remote: was.remote,
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })

      context('when the folder has children marked for deletion', () => {
        it('does not move them', async function() {
          const was = await builders
            .metadir()
            .path('OLD')
            .ino(666)
            .tags('courge', 'quux')
            .upToDate()
            .create()
          await builders
            .metafile()
            .path('OLD/child')
            .deleted()
            .changedSide('local')
            .create()
          const doc = builders
            .metadir(was)
            .path('NEW')
            .unmerged('local')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              'local',
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaults(
                {
                  sides: increasedSides(was.sides, 'local', 1),
                  moveFrom: was,
                  remote: was.remote,
                  _id: was._id
                },
                doc
              )
            ],
            resolvedConflicts: []
          })
        })
      })

      context('when the folder does not exist remotely', () => {
        let was, child
        beforeEach(async function() {
          was = await builders
            .metadir()
            .path('OLD')
            .ino(666)
            .tags('courge', 'quux')
            .sides({ local: 1 })
            .create()
          child = await builders
            .metafile()
            .path('OLD/child')
            .sides({ local: 1 })
            .create()
        })

        it('saves a local folder addition', async function() {
          const doc = builders
            .metadir(was)
            .path('NEW')
            .tags('courge', 'quux')
            .unmerged('local')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              'local',
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const folderAddition = _.defaults(
            {
              sides: { target: 1, local: 1 },
              _id: was._id
            },
            doc
          )
          const childAddition = _.defaultsDeep(
            {
              sides: { target: 1, local: 1 },
              local: {
                path: child.local.path.replace(was.local.path, doc.local.path)
              },
              path: child.path.replace(was.path, doc.path)
            },
            _.omit(child, ['_rev'])
          )
          should(sideEffects).deepEqual({
            savedDocs: [folderAddition, childAddition],
            resolvedConflicts: []
          })
        })

        context('and the destination exists', () => {
          let existing
          context('and it is up-to-date', () => {
            beforeEach(async function() {
              existing = await builders
                .metadir()
                .path('NEW')
                .upToDate()
                .create()
            })

            it('overwrites the destination', async function() {
              const doc = builders
                .metadir(was)
                .path(existing.path)
                .unmerged('local')
                .build()

              const sideEffects = await mergeSideEffects(this, () =>
                this.merge.moveFolderAsync(
                  'local',
                  _.cloneDeep(doc),
                  _.cloneDeep(was)
                )
              )

              const overwrittenFolder = {
                _deleted: true,
                _id: existing._id
              }
              const folderAddition = _.defaults(
                {
                  sides: { target: 1, local: 1 },
                  overwrite: existing,
                  _id: was._id
                },
                _.omit(doc, ['_rev'])
              )
              const childAddition = _.defaultsDeep(
                {
                  sides: { target: 1, local: 1 },
                  local: {
                    path: child.local.path.replace(
                      was.local.path,
                      doc.local.path
                    )
                  },
                  path: child.path.replace(was.path, doc.path)
                },
                _.omit(child, ['_rev'])
              )
              should(sideEffects).deepEqual({
                savedDocs: [overwrittenFolder, folderAddition, childAddition],
                resolvedConflicts: []
              })
            })
          })

          context(
            'and it is not at least up-to-date on the movement side',
            () => {
              beforeEach(async function() {
                existing = await builders
                  .metadir()
                  .path('NEW')
                  .changedSide('remote')
                  .create()
              })

              it('resolves a conflict', async function() {
                const doc = builders
                  .metadir(was)
                  .path(existing.path)
                  .unmerged('local')
                  .build()

                const sideEffects = await mergeSideEffects(this, () =>
                  this.merge.moveFolderAsync(
                    'local',
                    _.cloneDeep(doc),
                    _.cloneDeep(was)
                  )
                )

                const { path: dstPath } = _.find(
                  sideEffects.savedDocs,
                  ({ path, docType }) =>
                    docType === 'folder' && path.match(/conflict/)
                )

                const folderAddition = _.defaultsDeep(
                  {
                    path: dstPath,
                    local: { path: dstPath },
                    sides: { target: 1, local: 1 },
                    _id: was._id
                  },
                  doc
                )
                const childAddition = _.defaultsDeep(
                  {
                    path: child.path.replace(was.path, dstPath),
                    sides: { target: 1, local: 1 },
                    local: {
                      path: child.local.path.replace(was.local.path, dstPath)
                    }
                  },
                  _.omit(child, ['_rev'])
                )
                should(sideEffects).deepEqual({
                  savedDocs: [folderAddition, childAddition],
                  resolvedConflicts: [
                    ['local', _.pick(doc, ['path', 'remote'])]
                  ]
                })
              })
            }
          )
        })
      })
    })

    context('remote', () => {
      it('saves the moved folder', async function() {
        const oldRemoteDir = builders
          .remoteDir()
          .inRootDir()
          .name('OLD')
          .build()
        const was = await builders
          .metadir()
          .fromRemote(oldRemoteDir)
          .ino(666)
          .upToDate()
          .create()
        const newRemoteDir = builders
          .remoteDir(oldRemoteDir)
          .inRootDir()
          .name('NEW')
          .build()
        const doc = builders
          .metadir()
          .fromRemote(newRemoteDir)
          .unmerged('remote')
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            'remote',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              win32({ fileid: was.fileid }),
              {
                sides: increasedSides(was.sides, 'remote', 1),
                moveFrom: was,
                local: was.local,
                ino: was.ino,
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })

      context('when the folder does not exist locally', () => {
        let oldRemoteDir, was, child
        beforeEach(async function() {
          oldRemoteDir = builders
            .remoteDir()
            .inRootDir()
            .name('OLD')
            .build()
          was = await builders
            .metadir()
            .fromRemote(oldRemoteDir)
            .sides({ remote: 1 })
            .create()
          const remoteChild = builders
            .remoteFile()
            .inDir(oldRemoteDir)
            .name('child')
            .build()
          child = await builders
            .metafile()
            .fromRemote(remoteChild)
            .sides({ remote: 1 })
            .create()
        })

        it('saves a remote folder addition', async function() {
          const newRemoteDir = builders
            .remoteDir(oldRemoteDir)
            .name('NEW')
            .build()
          const doc = builders
            .metadir()
            .fromRemote(newRemoteDir)
            .unmerged('remote')
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              'remote',
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const folderAddition = _.defaults(
            {
              sides: { target: 1, remote: 1 },
              _id: was._id
            },
            doc
          )
          const childAddition = _.defaultsDeep(
            {
              sides: { target: 1, remote: 1 },
              remote: {
                path: child.remote.path.replace(
                  was.remote.path,
                  doc.remote.path
                )
              },
              path: child.path.replace(was.path, doc.path)
            },
            _.omit(child, ['_rev'])
          )
          should(sideEffects).deepEqual({
            savedDocs: [folderAddition, childAddition],
            resolvedConflicts: []
          })
        })

        context('and the destination exists', () => {
          let existing
          context('and it is up-to-date', () => {
            beforeEach(async function() {
              existing = await builders
                .metadir()
                .path('NEW')
                .upToDate()
                .create()
            })

            it('overwrites the destination', async function() {
              const newRemoteDir = builders
                .remoteDir(oldRemoteDir)
                .name('NEW')
                .build()
              const doc = builders
                .metadir(was)
                .fromRemote(newRemoteDir)
                .unmerged('remote')
                .build()

              const sideEffects = await mergeSideEffects(this, () =>
                this.merge.moveFolderAsync(
                  'remote',
                  _.cloneDeep(doc),
                  _.cloneDeep(was)
                )
              )

              const folderAddition = _.defaults(
                {
                  sides: { target: 1, remote: 1 },
                  overwrite: existing,
                  _id: was._id
                },
                doc
              )
              const childAddition = _.defaultsDeep(
                {
                  sides: { target: 1, remote: 1 },
                  remote: {
                    path: child.remote.path.replace(
                      was.remote.path,
                      doc.remote.path
                    )
                  },
                  path: child.path.replace(was.path, doc.path)
                },
                _.omit(child, ['_rev'])
              )
              should(sideEffects).deepEqual({
                savedDocs: [
                  {
                    _deleted: true,
                    _id: existing._id
                  },
                  folderAddition,
                  childAddition
                ],
                resolvedConflicts: []
              })
            })
          })

          context(
            'and it is not at least up-to-date on the movement side',
            () => {
              beforeEach(async function() {
                existing = await builders
                  .metadir()
                  .path('NEW')
                  .changedSide('local')
                  .create()
              })

              it('resolves a conflict', async function() {
                const newRemoteDir = builders
                  .remoteDir(oldRemoteDir)
                  .name('NEW')
                  .build()
                const doc = builders
                  .metadir(was)
                  .fromRemote(newRemoteDir)
                  .unmerged('remote')
                  .build()

                const sideEffects = await mergeSideEffects(this, () =>
                  this.merge.moveFolderAsync(
                    'remote',
                    _.cloneDeep(doc),
                    _.cloneDeep(was)
                  )
                )

                const { path: dstPath } = _.find(
                  sideEffects.savedDocs,
                  ({ path, docType }) =>
                    docType === 'folder' && path.match(/conflict/)
                )
                const remoteDstPath = pathUtils.localToRemote(dstPath)

                const folderAddition = _.defaultsDeep(
                  {
                    path: dstPath,
                    remote: { path: remoteDstPath },
                    sides: { target: 1, remote: 1 },
                    _id: was._id
                  },
                  doc
                )
                const childAddition = _.defaultsDeep(
                  {
                    path: child.path.replace(was.path, dstPath),
                    sides: { target: 1, remote: 1 },
                    remote: {
                      path: child.remote.path.replace(
                        was.remote.path,
                        remoteDstPath
                      )
                    }
                  },
                  _.omit(child, ['_rev'])
                )
                should(sideEffects).deepEqual({
                  savedDocs: [folderAddition, childAddition],
                  resolvedConflicts: [
                    ['remote', _.pick(doc, ['path', 'remote'])]
                  ]
                })
              })
            }
          )
        })
      })
    })

    context('when the destination exists', () => {
      let existing

      context('and it is up-to-date', () => {
        beforeEach(async function() {
          existing = await builders
            .metadir()
            .path('DST_DIR')
            .upToDate()
            .create()
        })

        it('overwrites the destination', async function() {
          const was = await builders
            .metadir()
            .path('SRC_DIR')
            .upToDate()
            .create()
          const doc = builders
            .metadir(was)
            .path(existing.path)
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              this.side,
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              {
                _deleted: true,
                _id: existing._id
              },
              _.defaults(
                {
                  path: existing.path,
                  sides: increasedSides(was.sides, this.side, 1),
                  moveFrom: was,
                  overwrite: existing,
                  [otherSide(this.side)]: was[otherSide(this.side)],
                  _id: was._id
                },
                doc
              )
            ],
            resolvedConflicts: []
          })
        })
      })

      context('and it is not at least up-to-date on the movement side', () => {
        beforeEach(async function() {
          existing = await builders
            .metadir()
            .path('DST_DIR')
            .changedSide(otherSide(this.side))
            .create()
        })

        it('resolves a conflict', async function() {
          const was = await builders
            .metadir()
            .path('SRC_DIR')
            .upToDate()
            .create()
          const doc = builders
            .metadir(was)
            .path(existing.path)
            .unmerged(this.side)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.moveFolderAsync(
              this.side,
              _.cloneDeep(doc),
              _.cloneDeep(was)
            )
          )

          const { path: dstPath } = _.find(sideEffects.savedDocs, ({ path }) =>
            path.match(/conflict/)
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaultsDeep(
                {
                  path: dstPath,
                  sides: increasedSides(was.sides, this.side, 1),
                  moveFrom: was,
                  [this.side]: { path: dstPath },
                  [otherSide(this.side)]: was[otherSide(this.side)],
                  _id: was._id
                },
                doc
              )
            ],
            resolvedConflicts: [[this.side, _.pick(doc, ['path', 'remote'])]]
          })
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_DIR'

      beforeEach(async function() {
        const previous = await builders
          .metadir()
          .path(path)
          .upToDate()
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new directory with the correct side', async function() {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: was,
                [otherSide(this.side)]: was[otherSide(this.side)],
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('does not create conflict for local-only existing folder.', async function() {
      const existing = await builders
        .metadir()
        .path('DST_DIR')
        .sides({ [this.side]: 1 })
        .create()
      const was = await builders
        .metadir()
        .path('SRC_DIR')
        .upToDate()
        .create()
      const doc = builders
        .metadir(was)
        .path(existing.path)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(
          this.side,
          _.cloneDeep(doc),
          _.cloneDeep(was)
        )
      )

      should(sideEffects).deepEqual({
        savedDocs: [
          {
            _deleted: true,
            _id: existing._id
          },
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: was,
              overwrite: existing,
              [otherSide(this.side)]: was[otherSide(this.side)],
              _id: was._id
            },
            doc
          )
        ],
        resolvedConflicts: []
      })
    })

    onPlatforms(['win32', 'darwin'], () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const apple = await builders
          .metadir()
          .path('apple')
          .upToDate()
          .create()
        const APPLE = builders
          .metadir(apple)
          .path('APPLE')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(APPLE),
            _.cloneDeep(apple)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaultsDeep(
              {
                sides: increasedSides(apple.sides, this.side, 1),
                moveFrom: apple,
                [otherSide(this.side)]: apple[otherSide(this.side)],
                _id: apple._id
              },
              APPLE
            )
          ],
          resolvedConflicts: []
        })
      })

      it('resolves an identity conflict when moving a synced folder to an existing path', async function() {
        await builders
          .metadir()
          .path('LINUX')
          .upToDate()
          .create()
        const torvalds = await builders
          .metadir()
          .path('torvalds')
          .upToDate()
          .create()
        const linux = builders
          .metadir(torvalds)
          .path('linux')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(linux),
            _.cloneDeep(torvalds)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [], // XXX: The conflict will be considered as a new change and merged later
          resolvedConflicts: [[this.side, _.pick(linux, ['path', 'remote'])]]
        })
      })
    })

    onPlatform('linux', () => {
      it('does not identify an identical renaming as a conflict', async function() {
        const apple = await builders
          .metadir()
          .path('apple')
          .upToDate()
          .create()
        const APPLE = builders
          .metadir(apple)
          .path('APPLE')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(APPLE),
            _.cloneDeep(apple)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(apple.sides, this.side, 1),
                moveFrom: apple,
                [otherSide(this.side)]: apple[otherSide(this.side)],
                _id: apple._id
              },
              APPLE
            )
          ],
          resolvedConflicts: []
        })
      })

      it('does not have identity conflicts', async function() {
        await builders
          .metadir()
          .path('NUKEM')
          .upToDate()
          .create()
        const duke = await builders
          .metadir()
          .path('duke')
          .upToDate()
          .create()
        const nukem = builders
          .metadir(duke)
          .path('nukem')
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderAsync(
            this.side,
            _.cloneDeep(nukem),
            _.cloneDeep(duke)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(duke.sides, this.side, 1),
                moveFrom: duke,
                [otherSide(this.side)]: duke[otherSide(this.side)],
                _id: duke._id
              },
              nukem
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    it('handles overwritten descendants', async function() {
      const srcDir = await builders
        .metadir()
        .path('src')
        .upToDate()
        .create()
      const srcFile = await builders
        .metafile()
        .path('src/file')
        .upToDate()
        .create()
      const oldDst = await builders
        .metadir()
        .path('dst')
        .upToDate()
        .create()
      const oldDstFile = await builders
        .metafile()
        .path('dst/file')
        .upToDate()
        .create()
      const dstDir = builders
        .metadir(srcDir)
        .path('dst')
        .overwrite(oldDst)
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderAsync(
          this.side,
          _.cloneDeep(dstDir),
          _.cloneDeep(srcDir)
        )
      )

      const movedSrcFile = _.defaults(
        {
          childMove: true
        },
        srcFile
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          {
            _deleted: true,
            _id: oldDst._id
          },
          {
            _deleted: true,
            _id: oldDstFile._id
          },
          _.defaults(
            {
              sides: increasedSides(srcDir.sides, this.side, 1),
              moveFrom: srcDir,
              overwrite: oldDst,
              [otherSide(this.side)]: srcDir[otherSide(this.side)],
              _id: srcDir._id
            },
            dstDir
          ),
          _.defaultsDeep(
            {
              path: oldDstFile.path,
              sides: increasedSides(srcFile.sides, this.side, 1),
              moveFrom: movedSrcFile,
              overwrite: oldDstFile,
              [this.side]: { path: oldDstFile[this.side].path }
            },
            _.omit(srcFile, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })
  })

  describe('moveFolderRecursively', function() {
    it('moves the folder and files/folders inside it', async function() {
      const was = await builders
        .metadir()
        .path('my-folder')
        .upToDate()
        .create()
      const subdir = await builders
        .metadir()
        .path('my-folder/folder-9')
        .upToDate()
        .create()
      const subfile = await builders
        .metafile()
        .path('my-folder/file-9')
        .upToDate()
        .create()
      const doc = builders
        .metadir(was)
        .path('DESTINATION')
        .unmerged(this.side)
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.moveFolderRecursivelyAsync(
          this.side,
          _.cloneDeep(doc),
          _.cloneDeep(was)
        )
      )

      const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

      const movedSubfile = _.defaults(
        {
          childMove: true
        },
        subfile
      )
      const movedSubdir = _.defaults(
        {
          childMove: true
        },
        subdir
      )
      should(sideEffects).deepEqual({
        savedDocs: [
          _.defaults(
            {
              sides: increasedSides(was.sides, this.side, 1),
              moveFrom: was,
              [otherSide(this.side)]: was[otherSide(this.side)],
              _id: was._id
            },
            doc
          ),
          _.defaultsDeep(
            {
              path: movedPath(subfile),
              sides: increasedSides(subfile.sides, this.side, 1),
              moveFrom: movedSubfile,
              [this.side]: { path: movedPath(subfile) },
              [otherSide(this.side)]: movedSubfile[otherSide(this.side)]
            },
            _.omit(subfile, ['_rev'])
          ),
          _.defaultsDeep(
            {
              path: movedPath(subdir),
              sides: increasedSides(subdir.sides, this.side, 1),
              moveFrom: movedSubdir,
              [this.side]: { path: movedPath(subdir) },
              [otherSide(this.side)]: movedSubdir[otherSide(this.side)]
            },
            _.omit(subdir, ['_rev'])
          )
        ],
        resolvedConflicts: []
      })
    })

    context('local with an unsynced remote file', () => {
      it('adds the remote file to the destination folder', async function() {
        const was = await builders
          .metadir()
          .path('ADDED_DIR')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path('MOVED_DIR')
          .unmerged('local')
          .build()
        const unsyncedRemoteFile = await builders
          .remoteFile()
          .inDir(was.remote)
          .name('unsynced-file')
          .build()
        const unsyncedFile = await builders
          .metafile()
          .fromRemote(unsyncedRemoteFile)
          .sides({ remote: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            'local',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, 'local', 1),
                moveFrom: was,
                remote: was.remote,
                _id: was._id
              },
              doc
            ),
            _.defaults(
              {
                path: movedPath(unsyncedFile),
                sides: { target: 1, remote: 1 }
              },
              _.omit(unsyncedFile, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('remote with an unsynced local file', () => {
      it('adds the local file to the destination folder', async function() {
        const oldRemoteDir = builders
          .remoteDir()
          .inRootDir()
          .name('ADDED_DIR')
          .build()
        const was = await builders
          .metadir()
          .fromRemote(oldRemoteDir)
          .upToDate()
          .create()
        const newRemoteDir = builders
          .remoteDir(oldRemoteDir)
          .name('MOVED_DIR')
          .build()
        const doc = builders
          .metadir()
          .fromRemote(newRemoteDir)
          .unmerged('remote')
          .build()
        const unsyncedFile = await builders
          .metafile()
          .path('ADDED_DIR/unsynced-file')
          .sides({ local: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            'remote',
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, 'remote', 1),
                moveFrom: was,
                local: was.local,
                _id: was._id
              },
              doc
            ),
            _.defaults(
              {
                path: movedPath(unsyncedFile),
                sides: { target: 1, local: 1 }
              },
              _.omit(unsyncedFile, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when the destination has existed', () => {
      const path = 'DST_DIR'

      beforeEach(async function() {
        const previous = await builders
          .metadir()
          .path(path)
          .upToDate()
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new directory with the correct side', async function() {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(path)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: was,
                [otherSide(this.side)]: was[otherSide(this.side)],
                _id: was._id
              },
              doc
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when the destination of a child has existed', () => {
      const parentPath = 'DST_DIR'
      const childName = 'CHILD'

      beforeEach(async function() {
        const previous = await builders
          .metadata()
          .path(`${parentPath}/${childName}`)
          .upToDate()
          .create()
        await this.pouch.remove(previous)
      })

      it('saves the new child with the correct side', async function() {
        const was = await builders
          .metadir()
          .path('SRC_DIR')
          .upToDate()
          .create()
        const child = await builders
          .metadata()
          .path(`SRC_DIR/${childName}`)
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .path(parentPath)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.moveFolderRecursivelyAsync(
            this.side,
            _.cloneDeep(doc),
            _.cloneDeep(was)
          )
        )

        const movedPath = oldDoc => oldDoc.path.replace(was.path, doc.path)

        const movedChild = _.defaults(
          {
            childMove: true
          },
          child
        )
        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                moveFrom: was,
                [otherSide(this.side)]: was[otherSide(this.side)],
                _id: was._id
              },
              doc
            ),
            _.defaultsDeep(
              {
                path: movedPath(child),
                sides: increasedSides(child.sides, this.side, 1),
                moveFrom: movedChild,
                [this.side]: { path: movedPath(child) },
                _id: child._id
              },
              _.omit(child, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    onPlatform('darwin', () => {
      context(
        'when the parent normalization differs in its children paths',
        () => {
          it('correctly replaces the NFD parent part in the children paths', async function() {
            const nfdParentPath = 'Énoncés'.normalize('NFD')
            const nfcParentPath = nfdParentPath.normalize('NFC')
            const was = await builders
              .metadir()
              .path(nfcParentPath)
              .upToDate()
              .create()
            const subdir = await builders
              .metadir()
              .path(path.join(nfdParentPath, 'folder-9'))
              .upToDate()
              .create()
            const subfile = await builders
              .metafile()
              .path(path.join(subdir.path, 'file-9'))
              .upToDate()
              .create()
            const doc = builders
              .metadir(was)
              .path('DESTINATION')
              .unmerged(this.side)
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.moveFolderRecursivelyAsync(
                this.side,
                _.cloneDeep(doc),
                _.cloneDeep(was)
              )
            )

            const movedSubdirPath = path.join(doc.path, 'folder-9')
            const movedSubdir = _.defaults(
              {
                childMove: true
              },
              subdir
            )
            const movedSubfilePath = path.join(movedSubdirPath, 'file-9')
            const movedSubfile = _.defaultsDeep(
              {
                childMove: true
              },
              subfile
            )
            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    sides: increasedSides(was.sides, this.side, 1),
                    moveFrom: was,
                    [otherSide(this.side)]: was[otherSide(this.side)],
                    _id: was._id
                  },
                  doc
                ),
                _.defaultsDeep(
                  {
                    path: movedSubdirPath,
                    sides: increasedSides(subdir.sides, this.side, 1),
                    moveFrom: movedSubdir,
                    [this.side]: { path: movedSubdirPath }
                  },
                  _.omit(subdir, ['_rev'])
                ),
                _.defaultsDeep(
                  {
                    path: movedSubfilePath,
                    sides: increasedSides(subfile.sides, this.side, 1),
                    moveFrom: movedSubfile,
                    [this.side]: { path: movedSubfilePath }
                  },
                  _.omit(subfile, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })

          it('correctly replaces the NFC parent part in the children paths', async function() {
            const nfdParentPath = 'Énoncés'.normalize('NFD')
            const nfcParentPath = nfdParentPath.normalize('NFC')
            const was = await builders
              .metadir()
              .path(nfdParentPath)
              .upToDate()
              .create()
            const subdir = await builders
              .metadir()
              .path(path.join(nfcParentPath, 'folder-9'))
              .upToDate()
              .create()
            const subfile = await builders
              .metafile()
              .path(path.join(subdir.path, 'file-9'))
              .upToDate()
              .create()
            const doc = builders
              .metadir(was)
              .path('DESTINATION')
              .unmerged(this.side)
              .build()

            const sideEffects = await mergeSideEffects(this, () =>
              this.merge.moveFolderRecursivelyAsync(
                this.side,
                _.cloneDeep(doc),
                _.cloneDeep(was)
              )
            )

            const movedSubdirPath = path.join(doc.path, 'folder-9')
            const movedSubdir = _.defaults(
              {
                childMove: true
              },
              subdir
            )
            const movedSubfilePath = path.join(movedSubdirPath, 'file-9')
            const movedSubfile = _.defaults(
              {
                childMove: true
              },
              subfile
            )
            should(sideEffects).deepEqual({
              savedDocs: [
                _.defaults(
                  {
                    sides: increasedSides(was.sides, this.side, 1),
                    moveFrom: was,
                    [otherSide(this.side)]: was[otherSide(this.side)],
                    _id: was._id
                  },
                  doc
                ),
                _.defaultsDeep(
                  {
                    path: movedSubdirPath,
                    sides: increasedSides(subdir.sides, this.side, 1),
                    moveFrom: movedSubdir,
                    [this.side]: { path: movedSubdirPath }
                  },
                  _.omit(subdir, ['_rev'])
                ),
                _.defaultsDeep(
                  {
                    path: movedSubfilePath,
                    sides: increasedSides(subfile.sides, this.side, 1),
                    moveFrom: movedSubfile,
                    [this.side]: { path: movedSubfilePath }
                  },
                  _.omit(subfile, ['_rev'])
                )
              ],
              resolvedConflicts: []
            })
          })
        }
      )
    })
  })

  describe('trashFolderAsync', () => {
    it('does not trash a folder if the other side has added a new file in it', async function() {
      const was = await builders
        .metadir()
        .path('trashed-folder')
        .upToDate()
        .create()
      await builders
        .metafile()
        .path('trashed-folder/file')
        .sides({ [otherSide(this.side)]: 1 })
        .create()
      const doc = await builders
        .metadir(was)
        .path(`.cozy_trash/${was.path}`)
        .trashed()
        .build()

      const sideEffects = await mergeSideEffects(this, () =>
        this.merge.trashFolderAsync(
          this.side,
          _.cloneDeep(was),
          _.cloneDeep(doc)
        )
      )

      should(sideEffects).deepEqual({
        savedDocs: [],
        resolvedConflicts: []
      })
    })
  })

  describe('deleteFileAsync', () => {
    context('when a record is found in Pouch', () => {
      it('deletes a file', async function() {
        const doc = await builders
          .metafile()
          .path('FILE')
          .data('content')
          .sides({ [this.side]: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('removes move hints', async function() {
        const old = await builders
          .metafile()
          .path('FILE')
          .data('content')
          .sides({ [this.side]: 1 })
          .create()
        const doc = await builders
          .metafile()
          .moveFrom(old)
          .path('MOVED')
          .sides({ [this.side]: 2 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['_rev', 'moveFrom'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a trashed record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metafile()
          .path('FILE')
          .trashed()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metafile(was)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was trashed
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a record marked for deletion is found in Pouch', () => {
      it('keeps the deletion marker and updates sides info', async function() {
        const was = await builders
          .metafile()
          .path('FILE')
          .deleted()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metafile(was)
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFileAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was marked for deletion
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('deleteFolderAsync', function() {
    context('when a record is found in Pouch', () => {
      it('deletes a folder', async function() {
        const doc = await builders
          .metadir()
          .path('FOLDER')
          .sides({ [this.side]: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('removes nested content', async function() {
        const doc = await builders
          .metadir()
          .path('FOLDER')
          .sides({ [this.side]: 1 })
          .create()
        const subdir = await builders
          .metafile()
          .path('FOLDER/DIR')
          .sides({ [this.side]: 1 })
          .create()
        const subsubdir = await builders
          .metafile()
          .path('FOLDER/DIR/DIR')
          .sides({ [this.side]: 1 })
          .create()
        const subsubsubfile = await builders
          .metafile()
          .path('FOLDER/DIR/DIR/FILE')
          .sides({ [this.side]: 1 })
          .data('content')
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(subsubsubfile.sides, this.side, 1),
                deleted: true
              },
              _.omit(subsubsubfile, ['_rev'])
            ),
            _.defaults(
              {
                sides: increasedSides(subsubdir.sides, this.side, 1),
                deleted: true
              },
              _.omit(subsubdir, ['_rev'])
            ),
            _.defaults(
              {
                sides: increasedSides(subdir.sides, this.side, 1),
                deleted: true
              },
              _.omit(subdir, ['_rev'])
            ),
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })

      it('removes move hints', async function() {
        // TODO: make sure we remove the move hints on children. This will be part
        // of a larger refactoring to make sure folders are trashed with their
        // hierarchy.
        const old = await builders
          .metadir()
          .path('FOLDER')
          .sides({ [this.side]: 1 })
          .create()
        const doc = await builders
          .metadir()
          .moveFrom(old)
          .path('MOVED')
          .sides({ [this.side]: 1 })
          .create()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(doc.sides, this.side, 1),
                deleted: true
              },
              _.omit(doc, ['_rev', 'moveFrom'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a trashed record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metadir()
          .path('FOLDER')
          .trashed()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was trashed
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a record marked for deletion is found in Pouch', () => {
      it('keeps the deletion marker and updates sides info', async function() {
        const was = await builders
          .metadir()
          .path('FOLDER')
          .deleted()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .unmerged(this.side)
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.deleteFolderAsync(this.side, _.cloneDeep(doc))
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was marked for deletion
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })

  describe('trashFileAsync', () => {
    context('when record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metafile()
          .upToDate()
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a trashed record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metafile()
          .trashed()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was trashed
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a record marked for deletion is found in Pouch', () => {
      context('and the record was modified on the other side', () => {
        it('completely erases the document from PouchDB', async function() {
          const was = await builders
            .metafile()
            .deleted()
            .changedSide(otherSide(this.side))
            .create()
          const doc = builders
            .metafile(was)
            .trashed()
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFileAsync(
              this.side,
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              {
                // _rev is removed from sideEffects
                _id: was._id,
                _deleted: true
              }
            ],
            resolvedConflicts: []
          })
        })
      })

      context('and the record was modified on the same side', () => {
        it('keeps the deletion marker and updates sides info', async function() {
          const was = await builders
            .metafile()
            .deleted()
            .changedSide(this.side)
            .create()
          const doc = builders
            .metafile(was)
            .trashed()
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFileAsync(
              this.side,
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaults(
                {
                  sides: increasedSides(was.sides, this.side, 1),
                  [this.side]: doc[this.side],
                  deleted: true
                },
                _.omit(was, ['_rev'])
              )
            ],
            resolvedConflicts: []
          })
        })
      })
    })

    context('when no records are found in Pouch', () => {
      it('does nothing', async function() {
        const was = builders.metafile().build()
        const doc = builders
          .metafile(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when docType of found record does not match', () => {
      it('does nothing', async function() {
        const was = await builders
          .metafile()
          .upToDate()
          .create()
        const doc = builders
          .metadir()
          .path(was.path)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when found record was not synced', () => {
      it('marks it for deletion and upadtes sides info', async function() {
        const was = await builders
          .metafile()
          .sides({ [this.side]: 1 })
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when found record was moved on the same side', () => {
      let initial, src
      beforeEach(async function() {
        initial = await builders
          .metafile()
          .path('initial')
          .upToDate()
          .create()
        src = await builders.metafile(initial).create()
      })

      it('marks the moved document for deletion', async function() {
        const was = await builders
          .metafile()
          .path('moved')
          .moveFrom(src)
          .changedSide(this.side)
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                deleted: true,
                sides: increasedSides(was.sides, this.side, 1)
              },
              _.omit(was, ['_rev', 'moveFrom'])
            )
          ],
          resolvedConflicts: []
        })
      })

      context('and the move was overwriting an existing doc', () => {
        let existing
        beforeEach(async function() {
          existing = await builders
            .metafile()
            .path('moved')
            .upToDate()
            .create()
        })

        it('marks the moved document for deletion', async function() {
          const was = await builders
            .metafile()
            .path('moved')
            .moveFrom(src)
            .overwrite(existing)
            .changedSide(this.side)
            .create()
          const doc = builders
            .metafile(was)
            .trashed()
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFileAsync(
              this.side,
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaults(
                {
                  deleted: true,
                  sides: increasedSides(existing.sides, this.side, 1)
                },
                _.omit(existing, ['_rev'])
              ),
              _.defaults(
                {
                  deleted: true,
                  sides: increasedSides(was.sides, this.side, 1)
                },
                _.omit(was, ['_rev', 'moveFrom', 'overwrite'])
              )
            ],
            resolvedConflicts: []
          })
        })
      })
    })

    context('when found record was modified on the same side', () => {
      it('marks it for deletion and updates sides info', async function() {
        const initial = await builders
          .metafile()
          .data('initial')
          .upToDate()
          .create()
        const was = await builders
          .metafile(initial)
          .data('updated')
          .changedSide(this.side)
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when found record was modified on the other side', () => {
      it('dissociates the record from the trashed side which is not saved', async function() {
        const initial = await builders
          .metafile()
          .data('initial')
          .upToDate()
          .create()
        const was = await builders
          .metafile(initial)
          .data('updated')
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metafile(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFileAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: _.omit(was.sides, this.side)
              },
              _.omit(was, ['_rev', this.side])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when trashed on local side', () => {
      context('and found record was moved on the remote side', () => {
        it('dissociates the record from the local side so it can be downloaded again', async function() {
          const initial = await builders
            .metafile()
            .path('initial')
            .upToDate()
            .create()
          const src = await builders.metafile(initial).create()
          const was = await builders
            .metafile()
            .moveFrom(src)
            .changedSide('remote')
            .create()
          const doc = builders
            .metafile(was)
            .trashed()
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFileAsync(
              'local',
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaults(
                {
                  sides: _.omit(was.sides, 'local')
                },
                _.omit(was, ['_rev', 'moveFrom', 'local'])
              )
            ],
            resolvedConflicts: []
          })
        })
      })
    })

    context('when trashed on remote side', () => {
      context('and found record was moved on the local side', () => {
        // FIXME: Moving a trashed file from outside the remote Trash is not
        // intended and will result in issues later as the remote file will keep
        // its `trashed` attribute.
        // We need to find a solution for this (e.g. restore the file before
        // moving it to its destination).
        it('updates the record remote revs so it can be restored', async function() {
          const initialRemote = await builders
            .remoteFile()
            .name('initial')
            .build()
          const initial = await builders
            .metafile()
            .fromRemote(initialRemote)
            .upToDate()
            .create()
          const src = await builders.metafile(initial).create()
          const was = await builders
            .metafile()
            .moveFrom(src)
            .changedSide('local')
            .create()
          const trashedRemote = await builders
            .remoteFile(initialRemote)
            .trashed()
            .build()
          const doc = builders
            .metafile()
            .fromRemote(trashedRemote)
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFileAsync(
              'remote',
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaultsDeep(
                {
                  remote: { _rev: trashedRemote._rev },
                  moveFrom: { remote: { _rev: trashedRemote._rev } }
                },
                _.omit(was, ['_rev'])
              )
            ],
            resolvedConflicts: []
          })
        })
      })
    })
  })

  describe('trashFolderAsync', () => {
    context('when record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metadir()
          .upToDate()
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a trashed record is found in Pouch', () => {
      it('marks it for deletion and updates sides info', async function() {
        const was = await builders
          .metadir()
          .trashed()
          .changedSide(otherSide(this.side))
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                // We increase the side by 2 since the other side was increased
                // when `was` was trashed
                sides: increasedSides(was.sides, this.side, 2),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })

    context('when a record marked for deletion is found in Pouch', () => {
      context('and the record was modified on the other side', () => {
        it('completely erases the record from PouchDB', async function() {
          const was = await builders
            .metadir()
            .deleted()
            .changedSide(otherSide(this.side))
            .create()
          const doc = builders
            .metadir(was)
            .trashed()
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFolderAsync(
              this.side,
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              {
                // _rev is removed from sideEffects
                _id: was._id,
                _deleted: true
              }
            ],
            resolvedConflicts: []
          })
        })
      })

      context('and the record was modified on the same side', () => {
        it('keeps the deletion marker and updates sides info', async function() {
          const was = await builders
            .metadir()
            .deleted()
            .changedSide(this.side)
            .create()
          const doc = builders
            .metadir(was)
            .trashed()
            .build()

          const sideEffects = await mergeSideEffects(this, () =>
            this.merge.trashFolderAsync(
              this.side,
              _.cloneDeep(was),
              _.cloneDeep(doc)
            )
          )

          should(sideEffects).deepEqual({
            savedDocs: [
              _.defaults(
                {
                  sides: increasedSides(was.sides, this.side, 1),
                  [this.side]: doc[this.side],
                  deleted: true
                },
                _.omit(was, ['_rev'])
              )
            ],
            resolvedConflicts: []
          })
        })
      })
    })

    context('when no records are found in Pouch', () => {
      it('does nothing', async function() {
        const was = builders.metadir().build()
        const doc = builders
          .metadir(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when docType of found record does not match', () => {
      it('does nothing', async function() {
        const was = await builders
          .metadir()
          .upToDate()
          .create()
        const doc = builders
          .metafile()
          .path(was.path)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [],
          resolvedConflicts: []
        })
      })
    })

    context('when found record was not synced', () => {
      it('marks it for deletion and upadtes sides info', async function() {
        const was = await builders
          .metadir()
          .sides({ [this.side]: 1 })
          .create()
        const doc = builders
          .metadir(was)
          .trashed()
          .build()

        const sideEffects = await mergeSideEffects(this, () =>
          this.merge.trashFolderAsync(
            this.side,
            _.cloneDeep(was),
            _.cloneDeep(doc)
          )
        )

        should(sideEffects).deepEqual({
          savedDocs: [
            _.defaults(
              {
                sides: increasedSides(was.sides, this.side, 1),
                [this.side]: doc[this.side],
                deleted: true
              },
              _.omit(was, ['_rev'])
            )
          ],
          resolvedConflicts: []
        })
      })
    })
  })
})
